!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;$/;"	t	class:rope
CAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeConcatenation<charT,Alloc>, Alloc> CAlloc;$/;"	t	struct:__rope_RopeBase
DEFALLOC_H	defalloc.h	26;"	d
DataAlloc	stl_rope.h	/^    	typedef simple_alloc<charT, Alloc> DataAlloc;$/;"	t	class:rope
DataAlloc	stl_rope.h	/^    typedef simple_alloc<charT, Alloc> DataAlloc;$/;"	t	struct:__rope_RopeBase
FAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;$/;"	t	class:rope
FAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeFunction<charT,Alloc>, Alloc> FAlloc;$/;"	t	struct:__rope_RopeBase
FREELIST_INDEX	stl_alloc.h	/^  static  size_t FREELIST_INDEX(size_t bytes) {$/;"	f	class:__default_alloc_template
LAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;$/;"	t	class:rope
LAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeLeaf<charT,Alloc>, Alloc> LAlloc;$/;"	t	struct:__rope_RopeBase
ROUND_UP	stl_alloc.h	/^  static size_t ROUND_UP(size_t bytes) {$/;"	f	class:__default_alloc_template
RopeBase	stl_rope.h	/^	typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:rope
RopeBase	stl_rope.h	/^    typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:__rope_charT_ref_proxy
RopeBase	stl_rope.h	/^    typedef __rope_RopeBase<charT,Alloc> RopeBase;$/;"	t	class:__rope_iterator_base
RopeConcatenation	stl_rope.h	/^	typedef __rope_RopeConcatenation<charT,Alloc> RopeConcatenation;$/;"	t	class:rope
RopeFunction	stl_rope.h	/^	typedef __rope_RopeFunction<charT,Alloc> RopeFunction;$/;"	t	class:rope
RopeFunction_from_fn	ropeimpl.h	/^rope<charT,Alloc>::RopeFunction_from_fn$/;"	f	class:rope
RopeLeaf	stl_rope.h	/^	typedef __rope_RopeLeaf<charT,Alloc> RopeLeaf;$/;"	t	class:rope
RopeLeaf_from_char_ptr	ropeimpl.h	/^rope<charT,Alloc>::RopeLeaf_from_char_ptr(__GC_CONST charT *s, size_t size)$/;"	f	class:rope
RopeLeaf_from_unowned_char_ptr	stl_rope.h	/^	static RopeLeaf * RopeLeaf_from_unowned_char_ptr(const charT *s,$/;"	f	class:rope
RopeSubstring	stl_rope.h	/^	typedef __rope_RopeSubstring<charT,Alloc> RopeSubstring;$/;"	t	class:rope
S	stl_function.h	/^  explicit const_mem_fun1_ref_t(S (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_ref_t
S	stl_function.h	/^  explicit const_mem_fun1_t(S (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_t
S	stl_function.h	/^  explicit const_mem_fun_ref_t(S (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_ref_t
S	stl_function.h	/^  explicit const_mem_fun_t(S (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_t
S	stl_function.h	/^  explicit mem_fun1_ref_t(S (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_ref_t
S	stl_function.h	/^  explicit mem_fun1_t(S (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_t
S	stl_function.h	/^  explicit mem_fun_ref_t(S (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_ref_t
S	stl_function.h	/^  explicit mem_fun_t(S (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_t
S	stl_function.h	/^inline const_mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A) const) {$/;"	f
S	stl_function.h	/^inline const_mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A) const) {$/;"	f
S	stl_function.h	/^inline const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const) {$/;"	f
S	stl_function.h	/^inline const_mem_fun_t<S,T> mem_fun(S (T::*f)() const) {$/;"	f
S	stl_function.h	/^inline mem_fun1_ref_t<S,T,A> mem_fun1_ref(S (T::*f)(A)) { $/;"	f
S	stl_function.h	/^inline mem_fun1_t<S,T,A> mem_fun1(S (T::*f)(A)) { $/;"	f
S	stl_function.h	/^inline mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)()) { $/;"	f
S	stl_function.h	/^inline mem_fun_t<S,T> mem_fun(S (T::*f)()) { $/;"	f
SAlloc	stl_rope.h	/^    	typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;$/;"	t	class:rope
SAlloc	stl_rope.h	/^    typedef simple_alloc<__rope_RopeSubstring<charT,Alloc>, Alloc> SAlloc;$/;"	t	struct:__rope_RopeBase
_NOTHREADS	stl_alloc.h	66;"	d
__ALIGN	stl_alloc.h	/^    enum {__ALIGN = 8};$/;"	e	enum:__default_alloc_template::__anon11
__ALIGN	stl_alloc.h	/^  enum {__ALIGN = 8};$/;"	e	enum:__anon8
__ALLOC	stl_alloc.h	50;"	d
__ALLOC_PAUSE	stl_alloc.h	605;"	d
__BVECTOR	stl_bvector.h	/^  __BVECTOR() : start(iterator()), finish(iterator()), end_of_storage(0) {}$/;"	f	class:vector
__BVECTOR	stl_bvector.h	/^  __BVECTOR(InputIterator first, InputIterator last) {$/;"	f	class:vector
__BVECTOR	stl_bvector.h	/^  __BVECTOR(const __BVECTOR& x) {$/;"	f	class:vector
__BVECTOR	stl_bvector.h	/^  __BVECTOR(const bool* first, const bool* last) {$/;"	f	class:vector
__BVECTOR	stl_bvector.h	/^  __BVECTOR(const_iterator first, const_iterator last) {$/;"	f	class:vector
__BVECTOR	stl_bvector.h	/^  __BVECTOR(int n, bool value) {$/;"	f	class:vector
__BVECTOR	stl_bvector.h	/^  __BVECTOR(long n, bool value) {$/;"	f	class:vector
__BVECTOR	stl_bvector.h	/^  __BVECTOR(size_type n, bool value) {$/;"	f	class:vector
__BVECTOR	stl_bvector.h	/^  explicit __BVECTOR(size_type n) {$/;"	f	class:vector
__BVECTOR	stl_bvector.h	247;"	d
__BVECTOR	stl_bvector.h	250;"	d
__BVECTOR	stl_bvector.h	604;"	d
__GC_CONST	stl_rope.h	22;"	d
__GC_CONST	stl_rope.h	24;"	d
__MAX_BYTES	stl_alloc.h	/^    enum {__MAX_BYTES = 128};$/;"	e	enum:__default_alloc_template::__anon12
__MAX_BYTES	stl_alloc.h	/^  enum {__MAX_BYTES = 128};$/;"	e	enum:__anon9
__NFREELISTS	stl_alloc.h	/^    enum {__NFREELISTS = __MAX_BYTES\/__ALIGN};$/;"	e	enum:__default_alloc_template::__anon13
__NFREELISTS	stl_alloc.h	/^  enum {__NFREELISTS = __MAX_BYTES\/__ALIGN};$/;"	e	enum:__anon10
__NODE_ALLOCATOR_LOCK	stl_alloc.h	102;"	d
__NODE_ALLOCATOR_LOCK	stl_alloc.h	111;"	d
__NODE_ALLOCATOR_LOCK	stl_alloc.h	74;"	d
__NODE_ALLOCATOR_LOCK	stl_alloc.h	84;"	d
__NODE_ALLOCATOR_THREADS	stl_alloc.h	106;"	d
__NODE_ALLOCATOR_THREADS	stl_alloc.h	113;"	d
__NODE_ALLOCATOR_THREADS	stl_alloc.h	78;"	d
__NODE_ALLOCATOR_THREADS	stl_alloc.h	88;"	d
__NODE_ALLOCATOR_UNLOCK	stl_alloc.h	104;"	d
__NODE_ALLOCATOR_UNLOCK	stl_alloc.h	112;"	d
__NODE_ALLOCATOR_UNLOCK	stl_alloc.h	76;"	d
__NODE_ALLOCATOR_UNLOCK	stl_alloc.h	86;"	d
__PRIVATE	stl_alloc.h	22;"	d
__PRIVATE	stl_alloc.h	26;"	d
__PRIVATE	stl_alloc.h	692;"	d
__RESTRICT	stl_alloc.h	61;"	d
__SGI_STL_ALGOBASE_H	algobase.h	27;"	d
__SGI_STL_ALGO_H	algo.h	28;"	d
__SGI_STL_ALLOC_H	alloc.h	15;"	d
__SGI_STL_BVECTOR_H	bvector.h	28;"	d
__SGI_STL_DEQUE_H	deque.h	28;"	d
__SGI_STL_FUNCTION_H	function.h	28;"	d
__SGI_STL_HASHTABLE_H	hashtable.h	32;"	d
__SGI_STL_HASH_FUN_H	stl_hash_fun.h	32;"	d
__SGI_STL_HASH_MAP_H	hash_map.h	28;"	d
__SGI_STL_HASH_SET_H	hash_set.h	28;"	d
__SGI_STL_HEAP_H	heap.h	27;"	d
__SGI_STL_INTERNAL_ALGOBASE_H	stl_algobase.h	33;"	d
__SGI_STL_INTERNAL_ALGO_H	stl_algo.h	32;"	d
__SGI_STL_INTERNAL_ALLOC_H	stl_alloc.h	19;"	d
__SGI_STL_INTERNAL_BVECTOR_H	stl_bvector.h	32;"	d
__SGI_STL_INTERNAL_CONSTRUCT_H	stl_construct.h	32;"	d
__SGI_STL_INTERNAL_DEQUE_H	stl_deque.h	32;"	d
__SGI_STL_INTERNAL_FUNCTION_H	stl_function.h	32;"	d
__SGI_STL_INTERNAL_HASHTABLE_H	stl_hashtable.h	32;"	d
__SGI_STL_INTERNAL_HASH_MAP_H	stl_hash_map.h	32;"	d
__SGI_STL_INTERNAL_HASH_SET_H	stl_hash_set.h	32;"	d
__SGI_STL_INTERNAL_HEAP_H	stl_heap.h	31;"	d
__SGI_STL_INTERNAL_ITERATOR_H	stl_iterator.h	32;"	d
__SGI_STL_INTERNAL_LIST_H	stl_list.h	32;"	d
__SGI_STL_INTERNAL_MAP_H	stl_map.h	32;"	d
__SGI_STL_INTERNAL_MULTIMAP_H	stl_multimap.h	32;"	d
__SGI_STL_INTERNAL_MULTISET_H	stl_multiset.h	32;"	d
__SGI_STL_INTERNAL_NUMERIC_H	stl_numeric.h	33;"	d
__SGI_STL_INTERNAL_PAIR_H	stl_pair.h	32;"	d
__SGI_STL_INTERNAL_QUEUE_H	stl_queue.h	32;"	d
__SGI_STL_INTERNAL_RAW_STORAGE_ITERATOR_H	stl_raw_storage_iter.h	32;"	d
__SGI_STL_INTERNAL_RELOPS	stl_relops.h	32;"	d
__SGI_STL_INTERNAL_ROPE_H	stl_rope.h	19;"	d
__SGI_STL_INTERNAL_SET_H	stl_set.h	32;"	d
__SGI_STL_INTERNAL_SLIST_H	stl_slist.h	20;"	d
__SGI_STL_INTERNAL_STACK_H	stl_stack.h	32;"	d
__SGI_STL_INTERNAL_TEMPBUF_H	stl_tempbuf.h	32;"	d
__SGI_STL_INTERNAL_TREE_H	stl_tree.h	34;"	d
__SGI_STL_INTERNAL_UNINITIALIZED_H	stl_uninitialized.h	32;"	d
__SGI_STL_INTERNAL_VECTOR_H	stl_vector.h	34;"	d
__SGI_STL_ITERATOR_H	iterator.h	28;"	d
__SGI_STL_LIST_H	list.h	28;"	d
__SGI_STL_MAP_H	map.h	28;"	d
__SGI_STL_MULTIMAP_H	multimap.h	28;"	d
__SGI_STL_MULTISET_H	multiset.h	28;"	d
__SGI_STL_NO_ARROW_OPERATOR	stl_config.h	146;"	d
__SGI_STL_NO_ARROW_OPERATOR	stl_config.h	159;"	d
__SGI_STL_PAIR_H	pair.h	28;"	d
__SGI_STL_PTHREAD_ALLOC_H	pthread_alloc.h	15;"	d
__SGI_STL_ROPE_H	rope.h	15;"	d
__SGI_STL_SET_H	set.h	28;"	d
__SGI_STL_SLIST_H	slist.h	16;"	d
__SGI_STL_STACK_H	stack.h	28;"	d
__SGI_STL_TEMPBUF_H	tempbuf.h	28;"	d
__SGI_STL_TREE_H	tree.h	30;"	d
__SGI_STL_VECBOOL_TEMPLATE	stl_bvector.h	246;"	d
__SGI_STL_VECBOOL_TEMPLATE	stl_bvector.h	249;"	d
__SGI_STL_VECBOOL_TEMPLATE	stl_bvector.h	603;"	d
__SGI_STL_VECTOR_H	vector.h	28;"	d
__STD	stl_config.h	199;"	d
__STD	stl_config.h	207;"	d
__STD_RELOPS	stl_config.h	205;"	d
__STD_RELOPS	stl_config.h	213;"	d
__STL_BEGIN_NAMESPACE	stl_config.h	200;"	d
__STL_BEGIN_NAMESPACE	stl_config.h	208;"	d
__STL_BEGIN_RELOPS_NAMESPACE	stl_config.h	203;"	d
__STL_BEGIN_RELOPS_NAMESPACE	stl_config.h	211;"	d
__STL_CATCH_ALL	stl_config.h	218;"	d
__STL_CATCH_ALL	stl_config.h	224;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	stl_config.h	110;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	stl_config.h	129;"	d
__STL_CLASS_PARTIAL_SPECIALIZATION	stl_config.h	82;"	d
__STL_CONFIG_H	stl_config.h	28;"	d
__STL_END_NAMESPACE	stl_config.h	201;"	d
__STL_END_NAMESPACE	stl_config.h	209;"	d
__STL_END_RELOPS_NAMESPACE	stl_config.h	204;"	d
__STL_END_RELOPS_NAMESPACE	stl_config.h	212;"	d
__STL_EXPLICIT_FUNCTION_TMPL_ARGS	stl_config.h	112;"	d
__STL_FUNCTION_TMPL_PARTIAL_ORDER	stl_config.h	111;"	d
__STL_LIMITED_DEFAULT_TEMPLATES	stl_config.h	158;"	d
__STL_MEMBER_TEMPLATES	stl_config.h	113;"	d
__STL_MEMBER_TEMPLATES	stl_config.h	128;"	d
__STL_MEMBER_TEMPLATES	stl_config.h	85;"	d
__STL_NEED_BOOL	stl_config.h	121;"	d
__STL_NEED_BOOL	stl_config.h	138;"	d
__STL_NEED_BOOL	stl_config.h	76;"	d
__STL_NEED_EXPLICIT	stl_config.h	107;"	d
__STL_NEED_EXPLICIT	stl_config.h	123;"	d
__STL_NEED_EXPLICIT	stl_config.h	143;"	d
__STL_NEED_EXPLICIT	stl_config.h	88;"	d
__STL_NEED_TYPENAME	stl_config.h	106;"	d
__STL_NEED_TYPENAME	stl_config.h	122;"	d
__STL_NEED_TYPENAME	stl_config.h	141;"	d
__STL_NEED_TYPENAME	stl_config.h	157;"	d
__STL_NEED_TYPENAME	stl_config.h	79;"	d
__STL_NON_TYPE_TMPL_PARAM_BUG	stl_config.h	145;"	d
__STL_NON_TYPE_TMPL_PARAM_BUG	stl_config.h	160;"	d
__STL_NOTHROW	stl_config.h	220;"	d
__STL_NOTHROW	stl_config.h	226;"	d
__STL_NO_DRAND48	stl_config.h	140;"	d
__STL_NO_DRAND48	stl_config.h	156;"	d
__STL_NULL_TMPL_ARGS	stl_config.h	185;"	d
__STL_NULL_TMPL_ARGS	stl_config.h	187;"	d
__STL_RETHROW	stl_config.h	219;"	d
__STL_RETHROW	stl_config.h	225;"	d
__STL_SGI_THREADS	stl_config.h	97;"	d
__STL_STATIC_TEMPLATE_MEMBER_BUG	stl_config.h	103;"	d
__STL_TEMPLATE_NULL	stl_config.h	191;"	d
__STL_TEMPLATE_NULL	stl_config.h	193;"	d
__STL_TRY	stl_config.h	217;"	d
__STL_TRY	stl_config.h	223;"	d
__STL_UNWIND	stl_config.h	221;"	d
__STL_UNWIND	stl_config.h	227;"	d
__STL_USE_EXCEPTIONS	stl_config.h	116;"	d
__STL_USE_EXCEPTIONS	stl_config.h	124;"	d
__STL_USE_EXCEPTIONS	stl_config.h	130;"	d
__STL_USE_EXCEPTIONS	stl_config.h	148;"	d
__STL_USE_EXCEPTIONS	stl_config.h	162;"	d
__STL_USE_EXCEPTIONS	stl_config.h	91;"	d
__STL_USE_NAMESPACES	stl_config.h	131;"	d
__STL_USE_NAMESPACES	stl_config.h	94;"	d
__STL_USE_NAMESPACE_FOR_RELOPS	stl_config.h	202;"	d
__STL_USE_NAMESPACE_FOR_RELOPS	stl_config.h	210;"	d
__STL_WIN32THREADS	stl_config.h	151;"	d
__STL_WIN32THREADS	stl_config.h	165;"	d
__THROW_BAD_ALLOC	stl_alloc.h	46;"	d
__TYPEDEF_WORKAROUND	stl_rope.h	97;"	d
__TYPE_TRAITS_H	type_traits.h	16;"	d
__USE_MALLOC	stl_alloc.h	30;"	d
__VOLATILE	stl_alloc.h	107;"	d
__VOLATILE	stl_alloc.h	114;"	d
__VOLATILE	stl_alloc.h	79;"	d
__VOLATILE	stl_alloc.h	89;"	d
__WORD_BIT	stl_bvector.h	/^static const int __WORD_BIT = int(CHAR_BIT*sizeof(unsigned int));$/;"	v
__add_and_fetch	stl_rope.h	288;"	d
__adjacent_difference	stl_numeric.h	/^OutputIterator __adjacent_difference(InputIterator first, InputIterator last, $/;"	f
__adjust_heap	stl_heap.h	/^void __adjust_heap(RandomAccessIterator first, Distance holeIndex,$/;"	f
__advance	stl_iterator.h	/^inline void __advance(BidirectionalIterator& i, Distance n, $/;"	f
__advance	stl_iterator.h	/^inline void __advance(InputIterator& i, Distance n, input_iterator_tag) {$/;"	f
__advance	stl_iterator.h	/^inline void __advance(RandomAccessIterator& i, Distance n, $/;"	f
__bit_const_iterator	stl_bvector.h	/^  __bit_const_iterator() : p(0), offset(0) {}$/;"	f	struct:__bit_const_iterator
__bit_const_iterator	stl_bvector.h	/^  __bit_const_iterator(const __bit_iterator& x) : p(x.p), offset(x.offset) {}$/;"	f	struct:__bit_const_iterator
__bit_const_iterator	stl_bvector.h	/^  __bit_const_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}$/;"	f	struct:__bit_const_iterator
__bit_const_iterator	stl_bvector.h	/^struct __bit_const_iterator$/;"	s
__bit_iterator	stl_bvector.h	/^  __bit_iterator() : p(0), offset(0) {}$/;"	f	struct:__bit_iterator
__bit_iterator	stl_bvector.h	/^  __bit_iterator(unsigned int* x, unsigned int y) : p(x), offset(y) {}$/;"	f	struct:__bit_iterator
__bit_iterator	stl_bvector.h	/^struct __bit_iterator : public random_access_iterator<bool, ptrdiff_t> {$/;"	s
__bit_reference	stl_bvector.h	/^  __bit_reference() : p(0), mask(0) {}$/;"	f	struct:__bit_reference
__bit_reference	stl_bvector.h	/^  __bit_reference(unsigned int* x, unsigned int y) : p(x), mask(y) {}$/;"	f	struct:__bit_reference
__bit_reference	stl_bvector.h	/^struct __bit_reference {$/;"	s
__black_count	stl_tree.h	/^inline int __black_count(__rb_tree_node_base* node, __rb_tree_node_base* root)$/;"	f
__chunk_insertion_sort	stl_algo.h	/^void __chunk_insertion_sort(RandomAccessIterator first, $/;"	f
__cond_store_eos	stl_rope.h	/^inline void __cond_store_eos(char& c) { c = 0; }$/;"	f
__cond_store_eos	stl_rope.h	/^inline void __cond_store_eos(charT&) {}$/;"	f
__cond_store_eos	stl_rope.h	/^inline void __cond_store_eos(wchar_t& c) { c = 0; }$/;"	f
__copy	stl_algobase.h	/^__copy(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__copy	stl_algobase.h	/^inline OutputIterator __copy(InputIterator first, InputIterator last,$/;"	f
__copy	stl_tree.h	/^rb_tree<K, V, KeyOfValue, Compare, Alloc>::__copy(link_type x, link_type p) {$/;"	f	class:rb_tree
__copy_backward	stl_algobase.h	/^inline BidirectionalIterator2 __copy_backward(BidirectionalIterator1 first, $/;"	f
__copy_backward_dispatch	stl_algobase.h	/^struct __copy_backward_dispatch$/;"	s
__copy_backward_dispatch	stl_algobase.h	/^struct __copy_backward_dispatch<T*, T*>$/;"	s
__copy_backward_dispatch	stl_algobase.h	/^struct __copy_backward_dispatch<const T*, T*>$/;"	s
__copy_backward_t	stl_algobase.h	/^inline T* __copy_backward_t(const T* first, const T* last, T* result,$/;"	f
__copy_d	stl_algobase.h	/^__copy_d(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__copy_dispatch	stl_algobase.h	/^struct __copy_dispatch$/;"	s
__copy_dispatch	stl_algobase.h	/^struct __copy_dispatch<T*, T*>$/;"	s
__copy_dispatch	stl_algobase.h	/^struct __copy_dispatch<const T*, T*>$/;"	s
__copy_n	stl_algobase.h	/^__copy_n(RandomAccessIterator first, Size count,$/;"	f
__copy_n	stl_algobase.h	/^pair<InputIterator, OutputIterator> __copy_n(InputIterator first, Size count,$/;"	f
__copy_t	stl_algobase.h	/^inline T* __copy_t(const T* first, const T* last, T* result, __false_type) {$/;"	f
__copy_t	stl_algobase.h	/^inline T* __copy_t(const T* first, const T* last, T* result, __true_type) {$/;"	f
__default_alloc_template	stl_alloc.h	/^    __default_alloc_template() {$/;"	f	class:__default_alloc_template
__default_alloc_template	stl_alloc.h	/^class __default_alloc_template {$/;"	c
__deque_buf_size	stl_deque.h	/^inline size_t __deque_buf_size(size_t n, size_t sz)$/;"	f
__deque_iterator	stl_deque.h	/^  __deque_iterator() : cur(0), first(0), last(0), node(0) {}$/;"	f	struct:__deque_iterator::__deque_iterator
__deque_iterator	stl_deque.h	/^  __deque_iterator(T* x, map_pointer y) $/;"	f	struct:__deque_iterator::__deque_iterator
__deque_iterator	stl_deque.h	/^  __deque_iterator(const iterator& x)$/;"	f	struct:__deque_iterator::__deque_iterator
__deque_iterator	stl_deque.h	/^struct __deque_iterator {$/;"	s
__deque_iterator	stl_deque.h	/^struct __deque_iterator {$/;"	s	struct:__deque_iterator
__destroy	stl_construct.h	/^inline void __destroy(ForwardIterator first, ForwardIterator last, T*) {$/;"	f
__destroy_aux	stl_construct.h	/^__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) {$/;"	f
__destroy_aux	stl_construct.h	/^inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}$/;"	f
__distance	stl_iterator.h	/^__distance(InputIterator first, InputIterator last, input_iterator_tag) {$/;"	f
__distance	stl_iterator.h	/^__distance(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__distance	stl_iterator.h	/^inline void __distance(InputIterator first, InputIterator last, Distance& n, $/;"	f
__distance	stl_iterator.h	/^inline void __distance(RandomAccessIterator first, RandomAccessIterator last, $/;"	f
__eos	stl_rope.h	/^inline charT __eos(charT*) { return charT(); }$/;"	f
__equal_range	stl_algo.h	/^__equal_range(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f
__equal_range	stl_algo.h	/^__equal_range(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__erase	stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__erase(link_type x) {$/;"	f	class:rb_tree
__false_type	type_traits.h	/^struct __false_type {$/;"	s
__final_insertion_sort	stl_algo.h	/^void __final_insertion_sort(RandomAccessIterator first, $/;"	f
__find_end	stl_algo.h	/^ForwardIterator1 __find_end(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
__find_end	stl_algo.h	/^__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,$/;"	f
__gcd	stl_algo.h	/^EuclideanRingElement __gcd(EuclideanRingElement m, EuclideanRingElement n)$/;"	f
__hashtable_const_iterator	stl_hashtable.h	/^  __hashtable_const_iterator() {}$/;"	f	struct:__hashtable_const_iterator
__hashtable_const_iterator	stl_hashtable.h	/^  __hashtable_const_iterator(const iterator& it) : cur(it.cur), ht(it.ht) {}$/;"	f	struct:__hashtable_const_iterator
__hashtable_const_iterator	stl_hashtable.h	/^  __hashtable_const_iterator(const node* n, const hashtable* tab)$/;"	f	struct:__hashtable_const_iterator
__hashtable_const_iterator	stl_hashtable.h	/^struct __hashtable_const_iterator {$/;"	s
__hashtable_iterator	stl_hashtable.h	/^  __hashtable_iterator() {}$/;"	f	struct:__hashtable_iterator
__hashtable_iterator	stl_hashtable.h	/^  __hashtable_iterator(node* n, hashtable* tab) : cur(n), ht(tab) {}$/;"	f	struct:__hashtable_iterator
__hashtable_iterator	stl_hashtable.h	/^struct __hashtable_iterator {$/;"	s
__hashtable_node	stl_hashtable.h	/^struct __hashtable_node$/;"	s
__inplace_merge_aux	stl_algo.h	/^inline void __inplace_merge_aux(BidirectionalIterator first,$/;"	f
__inplace_stable_partition	stl_algo.h	/^ForwardIterator __inplace_stable_partition(ForwardIterator first,$/;"	f
__inplace_stable_sort	stl_algo.h	/^void __inplace_stable_sort(RandomAccessIterator first,$/;"	f
__insert	stl_tree.h	/^__insert(base_ptr x_, base_ptr y_, const Value& v) {$/;"	f	class:rb_tree
__insertion_sort	stl_algo.h	/^void __insertion_sort(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
__insertion_sort	stl_algo.h	/^void __insertion_sort(RandomAccessIterator first,$/;"	f
__introsort_loop	stl_algo.h	/^void __introsort_loop(RandomAccessIterator first,$/;"	f
__is_basic_char_type	stl_rope.h	/^inline bool __is_basic_char_type(char *) { return true; }$/;"	f
__is_basic_char_type	stl_rope.h	/^inline bool __is_basic_char_type(charT *) { return false; }$/;"	f
__is_basic_char_type	stl_rope.h	/^inline bool __is_basic_char_type(wchar_t *) { return true; }$/;"	f
__is_heap	stl_algo.h	/^bool __is_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__is_one_byte_char_type	stl_rope.h	/^inline bool __is_one_byte_char_type(char *) { return true; }$/;"	f
__is_one_byte_char_type	stl_rope.h	/^inline bool __is_one_byte_char_type(charT *) { return false; }$/;"	f
__iter_swap	stl_algobase.h	/^inline void __iter_swap(ForwardIterator1 a, ForwardIterator2 b, T*) {$/;"	f
__lg	stl_algo.h	/^inline Size __lg(Size n) {$/;"	f
__linear_insert	stl_algo.h	/^inline void __linear_insert(RandomAccessIterator first, $/;"	f
__list_iterator	stl_list.h	/^  __list_iterator() {}$/;"	f	struct:__list_iterator
__list_iterator	stl_list.h	/^  __list_iterator(const iterator& x) : node(x.node) {}$/;"	f	struct:__list_iterator
__list_iterator	stl_list.h	/^  __list_iterator(link_type x) : node(x) {}$/;"	f	struct:__list_iterator
__list_iterator	stl_list.h	/^struct __list_iterator {$/;"	s
__list_node	stl_list.h	/^struct __list_node {$/;"	s
__lock	stl_alloc.h	/^__default_alloc_template<threads, inst>::__lock(volatile unsigned long *lock)$/;"	f	class:__default_alloc_template
__lower_bound	stl_algo.h	/^ForwardIterator __lower_bound(ForwardIterator first, ForwardIterator last,$/;"	f
__lower_bound	stl_algo.h	/^RandomAccessIterator __lower_bound(RandomAccessIterator first,$/;"	f
__make_heap	stl_heap.h	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,$/;"	f
__make_heap	stl_heap.h	/^void __make_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__malloc_alloc_oom_handler	stl_alloc.h	/^    static void (* __malloc_alloc_oom_handler)();$/;"	m	class:__malloc_alloc_template
__malloc_alloc_oom_handler	stl_alloc.h	/^    void (* __malloc_alloc_oom_handler)() = 0;$/;"	v
__malloc_alloc_oom_handler	stl_alloc.h	/^void (* __malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;$/;"	v
__malloc_alloc_template	stl_alloc.h	/^class __malloc_alloc_template {$/;"	c
__median	stl_algo.h	/^inline const T& __median(const T& a, const T& b, const T& c) {$/;"	f
__median	stl_algo.h	/^inline const T& __median(const T& a, const T& b, const T& c, Compare comp) {$/;"	f
__merge_adaptive	stl_algo.h	/^void __merge_adaptive(BidirectionalIterator first, $/;"	f
__merge_backward	stl_algo.h	/^BidirectionalIterator3 __merge_backward(BidirectionalIterator1 first1,$/;"	f
__merge_sort_loop	stl_algo.h	/^void __merge_sort_loop(RandomAccessIterator1 first,$/;"	f
__merge_sort_with_buffer	stl_algo.h	/^void __merge_sort_with_buffer(RandomAccessIterator first, $/;"	f
__merge_without_buffer	stl_algo.h	/^void __merge_without_buffer(BidirectionalIterator first,$/;"	f
__mutable_reference_at	stl_rope.h	/^inline crope::reference __mutable_reference_at(crope& c, size_t i)$/;"	f
__mutable_reference_at	stl_rope.h	/^inline wrope::reference __mutable_reference_at(wrope& c, size_t i)$/;"	f
__node_allocator_dummy_instance	stl_alloc.h	/^  static alloc __node_allocator_dummy_instance;$/;"	v
__node_allocator_lock	stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock$/;"	m	class:__default_alloc_template
__node_allocator_lock	stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock;$/;"	m	class:__default_alloc_template
__node_allocator_lock	stl_alloc.h	/^    static CRITICAL_SECTION __node_allocator_lock;$/;"	m	class:__default_alloc_template
__node_allocator_lock	stl_alloc.h	/^    static pthread_mutex_t __node_allocator_lock;$/;"	m	class:__default_alloc_template
__node_allocator_lock	stl_alloc.h	/^    static volatile unsigned long __node_allocator_lock;$/;"	m	class:__default_alloc_template
__node_allocator_lock	stl_alloc.h	/^__default_alloc_template<threads, inst>::__node_allocator_lock = 0;$/;"	m	class:__default_alloc_template
__node_allocator_lock_initialized	stl_alloc.h	/^    __default_alloc_template<threads, inst>::__node_allocator_lock_initialized$/;"	m	class:__default_alloc_template
__node_allocator_lock_initialized	stl_alloc.h	/^    static bool __node_allocator_lock_initialized;$/;"	m	class:__default_alloc_template
__nth_element	stl_algo.h	/^void __nth_element(RandomAccessIterator first, RandomAccessIterator nth,$/;"	f
__partial_sort	stl_algo.h	/^void __partial_sort(RandomAccessIterator first, RandomAccessIterator middle,$/;"	f
__partial_sort_copy	stl_algo.h	/^RandomAccessIterator __partial_sort_copy(InputIterator first,$/;"	f
__partial_sum	stl_numeric.h	/^OutputIterator __partial_sum(InputIterator first, InputIterator last,$/;"	f
__pop_heap	stl_heap.h	/^inline void __pop_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__pop_heap_aux	stl_heap.h	/^inline void __pop_heap_aux(RandomAccessIterator first,$/;"	f
__push_heap	stl_heap.h	/^void __push_heap(RandomAccessIterator first, Distance holeIndex,$/;"	f
__push_heap_aux	stl_heap.h	/^inline void __push_heap_aux(RandomAccessIterator first,$/;"	f
__random_sample	stl_algo.h	/^RandomAccessIterator __random_sample(InputIterator first, InputIterator last,$/;"	f
__random_shuffle	stl_algo.h	/^void __random_shuffle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__rb_tree_base_iterator	stl_tree.h	/^struct __rb_tree_base_iterator$/;"	s
__rb_tree_black	stl_tree.h	/^const __rb_tree_color_type __rb_tree_black = true;$/;"	v
__rb_tree_color_type	stl_tree.h	/^typedef bool __rb_tree_color_type;$/;"	t
__rb_tree_iterator	stl_tree.h	/^  __rb_tree_iterator() {}$/;"	f	struct:__rb_tree_iterator
__rb_tree_iterator	stl_tree.h	/^  __rb_tree_iterator(const iterator& it) { node = it.node; }$/;"	f	struct:__rb_tree_iterator
__rb_tree_iterator	stl_tree.h	/^  __rb_tree_iterator(link_type x) { node = x; }$/;"	f	struct:__rb_tree_iterator
__rb_tree_iterator	stl_tree.h	/^struct __rb_tree_iterator : public __rb_tree_base_iterator$/;"	s
__rb_tree_node	stl_tree.h	/^struct __rb_tree_node : public __rb_tree_node_base$/;"	s
__rb_tree_node_base	stl_tree.h	/^struct __rb_tree_node_base$/;"	s
__rb_tree_rebalance	stl_tree.h	/^__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f
__rb_tree_rebalance_for_erase	stl_tree.h	/^__rb_tree_rebalance_for_erase(__rb_tree_node_base* z,$/;"	f
__rb_tree_red	stl_tree.h	/^const __rb_tree_color_type __rb_tree_red = false;$/;"	v
__rb_tree_rotate_left	stl_tree.h	/^__rb_tree_rotate_left(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f
__rb_tree_rotate_right	stl_tree.h	/^__rb_tree_rotate_right(__rb_tree_node_base* x, __rb_tree_node_base*& root)$/;"	f
__rb_verify	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::__rb_verify() const$/;"	f	class:rb_tree
__reverse	stl_algo.h	/^void __reverse(BidirectionalIterator first, BidirectionalIterator last, $/;"	f
__reverse	stl_algo.h	/^void __reverse(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__rope_RopeBase	stl_rope.h	/^struct __rope_RopeBase {$/;"	s
__rope_RopeConcatenation	stl_rope.h	/^struct __rope_RopeConcatenation : public __rope_RopeBase<charT,Alloc> {$/;"	s
__rope_RopeFunction	stl_rope.h	/^struct __rope_RopeFunction : public __rope_RopeBase<charT,Alloc> {$/;"	s
__rope_RopeLeaf	stl_rope.h	/^struct __rope_RopeLeaf : public __rope_RopeBase<charT,Alloc> {$/;"	s
__rope_RopeSubstring	stl_rope.h	/^    __rope_RopeSubstring(__rope_RopeBase<charT,Alloc> * b, size_t s, size_t l) :$/;"	f	struct:__rope_RopeSubstring
__rope_RopeSubstring	stl_rope.h	/^struct __rope_RopeSubstring: public __rope_RopeFunction<charT,Alloc>,$/;"	s
__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy() {}$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy(charT * x) : root(0), pos(0) {$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy(const __rope_charT_ptr_proxy & x) :$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	stl_rope.h	/^    __rope_charT_ptr_proxy(const __rope_charT_ref_proxy<charT,Alloc> & x) :$/;"	f	class:__rope_charT_ptr_proxy
__rope_charT_ptr_proxy	stl_rope.h	/^class __rope_charT_ptr_proxy {$/;"	c
__rope_charT_ref_proxy	stl_rope.h	/^    __rope_charT_ref_proxy(my_rope * r, size_t p) :$/;"	f	class:__rope_charT_ref_proxy
__rope_charT_ref_proxy	stl_rope.h	/^    __rope_charT_ref_proxy(my_rope * r, size_t p,$/;"	f	class:__rope_charT_ref_proxy
__rope_charT_ref_proxy	stl_rope.h	/^class __rope_charT_ref_proxy {$/;"	c
__rope_char_consumer	stl_rope.h	/^class __rope_char_consumer {$/;"	c
__rope_const_iterator	ropeimpl.h	/^inline __rope_const_iterator<charT, Alloc>::__rope_const_iterator$/;"	f	class:__rope_const_iterator
__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator() {};$/;"	f	class:__rope_const_iterator
__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const RopeBase * root, size_t pos):$/;"	f	class:__rope_const_iterator
__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const __rope_const_iterator & x) :$/;"	f	class:__rope_const_iterator
__rope_const_iterator	stl_rope.h	/^    __rope_const_iterator(const rope<charT,Alloc> &r, size_t pos) :$/;"	f	class:__rope_const_iterator
__rope_const_iterator	stl_rope.h	/^class __rope_const_iterator : public __rope_iterator_base<charT,Alloc> {$/;"	c
__rope_fill	ropeimpl.h	/^inline void __rope_fill(ostream& o, size_t n)$/;"	f
__rope_find_char_char_consumer	ropeimpl.h	/^	__rope_find_char_char_consumer(charT p) : pattern(p), count(0) {}$/;"	f	class:__rope_find_char_char_consumer
__rope_find_char_char_consumer	ropeimpl.h	/^class __rope_find_char_char_consumer : public __rope_char_consumer<charT> {$/;"	c
__rope_flatten_char_consumer	ropeimpl.h	/^	__rope_flatten_char_consumer(charT * buffer) {$/;"	f	class:__rope_flatten_char_consumer
__rope_flatten_char_consumer	ropeimpl.h	/^class __rope_flatten_char_consumer : public __rope_char_consumer<charT> {$/;"	c
__rope_insert_char_consumer	ropeimpl.h	/^	__rope_insert_char_consumer(insert_ostream & writer) : o(writer) {};$/;"	f	class:__rope_insert_char_consumer
__rope_insert_char_consumer	ropeimpl.h	/^class __rope_insert_char_consumer : public __rope_char_consumer<charT> {$/;"	c
__rope_is_simple	ropeimpl.h	/^inline bool __rope_is_simple(char *) { return true; }$/;"	f
__rope_is_simple	ropeimpl.h	/^inline bool __rope_is_simple(wchar_t *) { return true; }$/;"	f
__rope_is_simple	ropeimpl.h	/^template <class charT> inline bool __rope_is_simple(charT *) { return false; }$/;"	f
__rope_iterator	ropeimpl.h	/^inline __rope_iterator<charT,Alloc>::__rope_iterator$/;"	f	class:__rope_iterator
__rope_iterator	stl_rope.h	/^    __rope_iterator() {$/;"	f	class:__rope_iterator
__rope_iterator	stl_rope.h	/^    __rope_iterator(const __rope_iterator & x) :$/;"	f	class:__rope_iterator
__rope_iterator	stl_rope.h	/^    __rope_iterator(rope<charT,Alloc> * r, size_t pos):$/;"	f	class:__rope_iterator
__rope_iterator	stl_rope.h	/^class __rope_iterator : public __rope_iterator_base<charT,Alloc> {$/;"	c
__rope_iterator_base	stl_rope.h	/^    __rope_iterator_base() {}$/;"	f	class:__rope_iterator_base
__rope_iterator_base	stl_rope.h	/^    __rope_iterator_base(RopeBase * root, size_t pos):$/;"	f	class:__rope_iterator_base
__rope_iterator_base	stl_rope.h	/^    __rope_iterator_base(const __rope_iterator_base& x) {$/;"	f	class:__rope_iterator_base
__rope_iterator_base	stl_rope.h	/^class __rope_iterator_base:$/;"	c
__rope_rotate	ropeimpl.h	/^__rope_rotate(__rope_iterator<charT,Alloc> first,$/;"	f
__rope_self_destruct_ptr	stl_rope.h	/^	__rope_self_destruct_ptr() : ptr(0) {};$/;"	f	struct:__rope_self_destruct_ptr
__rope_self_destruct_ptr	stl_rope.h	/^	__rope_self_destruct_ptr() {};$/;"	f	struct:__rope_self_destruct_ptr
__rope_self_destruct_ptr	stl_rope.h	/^    __rope_self_destruct_ptr(__rope_RopeBase<charT,Alloc> * p) : ptr(p) {}$/;"	f	struct:__rope_self_destruct_ptr
__rope_self_destruct_ptr	stl_rope.h	/^  struct __rope_self_destruct_ptr {$/;"	s
__rotate	stl_algo.h	/^void __rotate(BidirectionalIterator first, BidirectionalIterator middle,$/;"	f
__rotate	stl_algo.h	/^void __rotate(ForwardIterator first, ForwardIterator middle,$/;"	f
__rotate	stl_algo.h	/^void __rotate(RandomAccessIterator first, RandomAccessIterator middle,$/;"	f
__rotate_adaptive	stl_algo.h	/^BidirectionalIterator1 __rotate_adaptive(BidirectionalIterator1 first,$/;"	f
__rotate_cycle	stl_algo.h	/^void __rotate_cycle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
__search	stl_algo.h	/^ForwardIterator1 __search(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
__slist_iterator	stl_slist.h	/^  __slist_iterator() : __slist_iterator_base(0) {}$/;"	f	struct:__slist_iterator
__slist_iterator	stl_slist.h	/^  __slist_iterator(const iterator& x) : __slist_iterator_base(x.node) {}$/;"	f	struct:__slist_iterator
__slist_iterator	stl_slist.h	/^  __slist_iterator(list_node* x) : __slist_iterator_base(x) {}$/;"	f	struct:__slist_iterator
__slist_iterator	stl_slist.h	/^struct __slist_iterator : public __slist_iterator_base$/;"	s
__slist_iterator_base	stl_slist.h	/^  __slist_iterator_base(__slist_node_base* x) : node(x) {}$/;"	f	struct:__slist_iterator_base
__slist_iterator_base	stl_slist.h	/^struct __slist_iterator_base$/;"	s
__slist_make_link	stl_slist.h	/^inline __slist_node_base* __slist_make_link(__slist_node_base* prev_node,$/;"	f
__slist_node	stl_slist.h	/^struct __slist_node : public __slist_node_base$/;"	s
__slist_node_base	stl_slist.h	/^struct __slist_node_base$/;"	s
__slist_previous	stl_slist.h	/^inline __slist_node_base* __slist_previous(__slist_node_base* head,$/;"	f
__slist_previous	stl_slist.h	/^inline const __slist_node_base* __slist_previous(const __slist_node_base* head,$/;"	f
__slist_reverse	stl_slist.h	/^inline __slist_node_base* __slist_reverse(__slist_node_base* node)$/;"	f
__slist_size	stl_slist.h	/^inline size_t __slist_size(__slist_node_base* node)$/;"	f
__slist_splice_after	stl_slist.h	/^inline void __slist_splice_after(__slist_node_base* pos,$/;"	f
__stable_partition_adaptive	stl_algo.h	/^ForwardIterator __stable_partition_adaptive(ForwardIterator first,$/;"	f
__stable_partition_aux	stl_algo.h	/^inline ForwardIterator __stable_partition_aux(ForwardIterator first,$/;"	f
__stable_sort_adaptive	stl_algo.h	/^void __stable_sort_adaptive(RandomAccessIterator first, $/;"	f
__stable_sort_aux	stl_algo.h	/^inline void __stable_sort_aux(RandomAccessIterator first,$/;"	f
__stl_assert	stl_config.h	232;"	d
__stl_assert	stl_config.h	236;"	d
__stl_chunk_size	stl_algo.h	/^const int __stl_chunk_size = 7;$/;"	v
__stl_hash_string	stl_hash_fun.h	/^inline size_t __stl_hash_string(const char* s)$/;"	f
__stl_next_prime	stl_hashtable.h	/^inline unsigned long __stl_next_prime(unsigned long n)$/;"	f
__stl_num_primes	stl_hashtable.h	/^static const int __stl_num_primes = 28;$/;"	v
__stl_prime_list	stl_hashtable.h	/^static const unsigned long __stl_prime_list[__stl_num_primes] =$/;"	v
__stl_threshold	stl_algo.h	/^const int __stl_threshold = 16;$/;"	v
__test_and_set	stl_alloc.h	590;"	d
__true_type	type_traits.h	/^struct __true_type {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<char> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<double> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<float> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<int> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<long double> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<long> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<short> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<signed char> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned char> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned int> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned long> {$/;"	s
__type_traits	type_traits.h	/^__STL_TEMPLATE_NULL struct __type_traits<unsigned short> {$/;"	s
__type_traits	type_traits.h	/^struct __type_traits { $/;"	s
__type_traits	type_traits.h	/^struct __type_traits<T*> {$/;"	s
__type_traits	type_traits.h	/^struct __type_traits<char*> {$/;"	s
__type_traits	type_traits.h	/^struct __type_traits<signed char*> {$/;"	s
__type_traits	type_traits.h	/^struct __type_traits<unsigned char*> {$/;"	s
__unguarded_insertion_sort	stl_algo.h	/^inline void __unguarded_insertion_sort(RandomAccessIterator first, $/;"	f
__unguarded_insertion_sort_aux	stl_algo.h	/^void __unguarded_insertion_sort_aux(RandomAccessIterator first, $/;"	f
__unguarded_linear_insert	stl_algo.h	/^void __unguarded_linear_insert(RandomAccessIterator last, T value) {$/;"	f
__unguarded_linear_insert	stl_algo.h	/^void __unguarded_linear_insert(RandomAccessIterator last, T value, $/;"	f
__unguarded_partition	stl_algo.h	/^RandomAccessIterator __unguarded_partition(RandomAccessIterator first, $/;"	f
__uninitialized_copy	stl_uninitialized.h	/^__uninitialized_copy(InputIterator first, InputIterator last,$/;"	f
__uninitialized_copy_aux	stl_uninitialized.h	/^__uninitialized_copy_aux(InputIterator first, InputIterator last,$/;"	f
__uninitialized_copy_copy	stl_uninitialized.h	/^__uninitialized_copy_copy(InputIterator1 first1, InputIterator1 last1,$/;"	f
__uninitialized_copy_fill	stl_uninitialized.h	/^__uninitialized_copy_fill(InputIterator first1, InputIterator last1,$/;"	f
__uninitialized_copy_n	stl_uninitialized.h	/^__uninitialized_copy_n(InputIterator first, Size count,$/;"	f
__uninitialized_copy_n	stl_uninitialized.h	/^__uninitialized_copy_n(RandomAccessIterator first, Size count,$/;"	f
__uninitialized_fill	stl_uninitialized.h	/^inline void __uninitialized_fill(ForwardIterator first, ForwardIterator last, $/;"	f
__uninitialized_fill_aux	stl_uninitialized.h	/^__uninitialized_fill_aux(ForwardIterator first, ForwardIterator last, $/;"	f
__uninitialized_fill_copy	stl_uninitialized.h	/^__uninitialized_fill_copy(ForwardIterator result, ForwardIterator mid,$/;"	f
__uninitialized_fill_n	stl_uninitialized.h	/^inline ForwardIterator __uninitialized_fill_n(ForwardIterator first, Size n,$/;"	f
__uninitialized_fill_n_aux	stl_uninitialized.h	/^__uninitialized_fill_n_aux(ForwardIterator first, Size n,$/;"	f
__unique_copy	stl_algo.h	/^ForwardIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f
__unique_copy	stl_algo.h	/^OutputIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f
__unique_copy	stl_algo.h	/^inline OutputIterator __unique_copy(InputIterator first, InputIterator last,$/;"	f
__unlock	stl_alloc.h	/^__default_alloc_template<threads, inst>::__unlock(volatile unsigned long *lock)$/;"	f	class:__default_alloc_template
__upper_bound	stl_algo.h	/^ForwardIterator __upper_bound(ForwardIterator first, ForwardIterator last,$/;"	f
__upper_bound	stl_algo.h	/^RandomAccessIterator __upper_bound(RandomAccessIterator first,$/;"	f
_insert_after	stl_slist.h	/^  list_node* _insert_after(list_node_base* pos, const value_type& x) {$/;"	f	class:slist
_insert_after_fill	stl_slist.h	/^  void _insert_after_fill(list_node_base* pos,$/;"	f	class:slist
_insert_after_range	stl_slist.h	/^  void _insert_after_range(list_node_base* pos, InIter first, InIter last) {$/;"	f	class:slist
_insert_after_range	stl_slist.h	/^  void _insert_after_range(list_node_base* pos,$/;"	f	class:slist
accumulate	stl_numeric.h	/^T accumulate(InputIterator first, InputIterator last, T init) {$/;"	f
accumulate	stl_numeric.h	/^T accumulate(InputIterator first, InputIterator last, T init,$/;"	f
add_leaf_to_forest	ropeimpl.h	/^rope<charT,Alloc>::add_leaf_to_forest(RopeBase *r, RopeBase **forest)$/;"	f	class:rope
add_to_forest	ropeimpl.h	/^rope<charT,Alloc>::add_to_forest(RopeBase *r, RopeBase **forest)$/;"	f	class:rope
address	defalloc.h	/^    pointer address(reference x) { return (pointer)&x; }$/;"	f	class:allocator
adjacent_difference	stl_numeric.h	/^OutputIterator adjacent_difference(InputIterator first, InputIterator last, $/;"	f
adjacent_difference	stl_numeric.h	/^OutputIterator adjacent_difference(InputIterator first, InputIterator last,$/;"	f
adjacent_find	stl_algo.h	/^ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last) {$/;"	f
adjacent_find	stl_algo.h	/^ForwardIterator adjacent_find(ForwardIterator first, ForwardIterator last,$/;"	f
advance	stl_iterator.h	/^inline void advance(InputIterator& i, Distance n) {$/;"	f
alloc	stl_alloc.h	/^typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;$/;"	t
alloc	stl_alloc.h	/^typedef malloc_alloc alloc;$/;"	t
alloc_copy	stl_rope.h	/^	static charT * alloc_copy(const charT *s, size_t size)$/;"	f	class:rope
alloc_granularity	stl_rope.h	/^    enum { alloc_granularity = 8 };$/;"	e	enum:__rope_RopeBase::__anon3
allocate	defalloc.h	/^    pointer allocate(size_type n) { $/;"	f	class:allocator
allocate	defalloc.h	/^inline T* allocate(ptrdiff_t size, T*) {$/;"	f
allocate	stl_alloc.h	/^    static T *allocate(size_t n)$/;"	f	class:simple_alloc
allocate	stl_alloc.h	/^    static T *allocate(void)$/;"	f	class:simple_alloc
allocate	stl_alloc.h	/^  static void * allocate(size_t n)$/;"	f	class:__default_alloc_template
allocate	stl_alloc.h	/^static void * allocate(size_t n)$/;"	f	class:__malloc_alloc_template
allocate	stl_alloc.h	/^static void * allocate(size_t n)$/;"	f	class:debug_alloc
allocate_and_copy	stl_vector.h	/^  iterator allocate_and_copy(size_type n,$/;"	f	class:vector
allocate_and_fill	stl_vector.h	/^  iterator allocate_and_fill(size_type n, const T& x) {$/;"	f	class:vector
allocate_buffer	stl_tempbuf.h	/^  void allocate_buffer() {$/;"	f	class:temporary_buffer
allocate_node	stl_deque.h	/^  pointer allocate_node() { return data_allocator::allocate(buffer_size()); }$/;"	f	class:__deque_iterator::deque
allocated_capacity	stl_rope.h	/^	static size_t allocated_capacity(size_t n) {$/;"	f	class:rope
allocator	defalloc.h	/^class allocator {$/;"	c
allocator	defalloc.h	/^class allocator<void> {$/;"	c
append	stl_rope.h	/^	rope& append() { return append(charT()); }$/;"	f	class:rope
append	stl_rope.h	/^	rope& append(charT c) {$/;"	f	class:rope
append	stl_rope.h	/^	rope& append(const charT* c_string) {$/;"	f	class:rope
append	stl_rope.h	/^	rope& append(const charT* iter, size_t n) {$/;"	f	class:rope
append	stl_rope.h	/^	rope& append(const charT* s, const charT* e) {$/;"	f	class:rope
append	stl_rope.h	/^	rope& append(const rope& y) {$/;"	f	class:rope
append	stl_rope.h	/^	rope& append(const_iterator s, const_iterator e) {$/;"	f	class:rope
append	stl_rope.h	/^	rope& append(size_t n, charT c) {$/;"	f	class:rope
append	stl_rope.h	/^	void append(value_type *s, size_t len)$/;"	f	class:sequence_buffer
apply_to_pieces	ropeimpl.h	/^bool rope<charT, Alloc>::apply_to_pieces($/;"	f	class:rope
apply_to_pieces	stl_rope.h	/^	void apply_to_pieces( size_t begin, size_t end,$/;"	f	class:rope
argument_type	stl_function.h	/^    typedef Arg argument_type;$/;"	t	struct:unary_function
at	stl_rope.h	/^	    reference at(size_type pos) {$/;"	f	class:rope
at	stl_rope.h	/^	charT at(size_type pos) const {$/;"	f	class:rope
atomic_swap	stl_rope.h	/^	    static cstrptr atomic_swap(cstrptr *p, cstrptr q) {$/;"	f	class:rope
back	stl_bvector.h	/^  const_reference back() const { return *(end() - 1); }$/;"	f	class:vector
back	stl_bvector.h	/^  reference back() { return *(end() - 1); }$/;"	f	class:vector
back	stl_deque.h	/^  const_reference back() const {$/;"	f	class:__deque_iterator::deque
back	stl_deque.h	/^  reference back() {$/;"	f	class:__deque_iterator::deque
back	stl_list.h	/^  const_reference back() const { return *(--end()); }$/;"	f	class:list
back	stl_list.h	/^  reference back() { return *(--end()); }$/;"	f	class:list
back	stl_queue.h	/^  const_reference back() const { return c.back(); }$/;"	f	class:queue
back	stl_queue.h	/^  reference back() { return c.back(); }$/;"	f	class:queue
back	stl_rope.h	/^	charT back() const$/;"	f	class:rope
back	stl_vector.h	/^  const_reference back() const { return *(end() - 1); }$/;"	f	class:vector
back	stl_vector.h	/^  reference back() { return *(end() - 1); }$/;"	f	class:vector
back_insert_iterator	stl_iterator.h	/^  explicit back_insert_iterator(Container& x) : container(&x) {}$/;"	f	class:back_insert_iterator
back_insert_iterator	stl_iterator.h	/^class back_insert_iterator {$/;"	c
back_inserter	stl_iterator.h	/^inline back_insert_iterator<Container> back_inserter(Container& x) {$/;"	f
balance	ropeimpl.h	/^rope<charT,Alloc>::balance(RopeBase *r)$/;"	f	class:rope
balance	stl_rope.h	/^	void balance()$/;"	f	class:rope
base	stl_iterator.h	/^  BidirectionalIterator base() const { return current; }$/;"	f	class:reverse_bidirectional_iterator
base	stl_iterator.h	/^  RandomAccessIterator base() const { return current; }$/;"	f	class:reverse_iterator
base	stl_iterator.h	/^  iterator_type base() const { return current; }$/;"	f	class:reverse_iterator
base	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * base;	\/\/ not 0$/;"	m	struct:__rope_RopeSubstring
base_ptr	stl_tree.h	/^  typedef __rb_tree_node_base* base_ptr;$/;"	t	class:rb_tree
base_ptr	stl_tree.h	/^  typedef __rb_tree_node_base* base_ptr;$/;"	t	struct:__rb_tree_node_base
base_ptr	stl_tree.h	/^  typedef __rb_tree_node_base::base_ptr base_ptr;$/;"	t	struct:__rb_tree_base_iterator
begin	stl_bvector.h	/^  const_iterator begin() const { return start; }$/;"	f	class:vector
begin	stl_bvector.h	/^  iterator begin() { return start; }$/;"	f	class:vector
begin	stl_deque.h	/^  const_iterator begin() const { return start; }$/;"	f	class:__deque_iterator::deque
begin	stl_deque.h	/^  iterator begin() { return start; }$/;"	f	class:__deque_iterator::deque
begin	stl_hash_map.h	/^  const_iterator begin() const { return rep.begin(); }$/;"	f	class:hash_map
begin	stl_hash_map.h	/^  const_iterator begin() const { return rep.begin(); }$/;"	f	class:hash_multimap
begin	stl_hash_map.h	/^  iterator begin() { return rep.begin(); }$/;"	f	class:hash_map
begin	stl_hash_map.h	/^  iterator begin() { return rep.begin(); }$/;"	f	class:hash_multimap
begin	stl_hash_set.h	/^  iterator begin() const { return rep.begin(); }$/;"	f	class:hash_multiset
begin	stl_hash_set.h	/^  iterator begin() const { return rep.begin(); }$/;"	f	class:hash_set
begin	stl_hashtable.h	/^  const_iterator begin() const$/;"	f	class:hashtable
begin	stl_hashtable.h	/^  iterator begin()$/;"	f	class:hashtable
begin	stl_list.h	/^  const_iterator begin() const { return (link_type)((*node).next); }$/;"	f	class:list
begin	stl_list.h	/^  iterator begin() { return (link_type)((*node).next); }$/;"	f	class:list
begin	stl_map.h	/^  const_iterator begin() const { return t.begin(); }$/;"	f	class:map
begin	stl_map.h	/^  iterator begin() { return t.begin(); }$/;"	f	class:map
begin	stl_multimap.h	/^  const_iterator begin() const { return t.begin(); }$/;"	f	class:multimap
begin	stl_multimap.h	/^  iterator begin() { return t.begin(); }$/;"	f	class:multimap
begin	stl_multiset.h	/^  iterator begin() const { return t.begin(); }$/;"	f	class:multiset
begin	stl_rope.h	/^	    const_iterator begin() { return const_begin(); }$/;"	f	class:rope
begin	stl_rope.h	/^	    iterator begin() { return mutable_begin(); }$/;"	f	class:rope
begin	stl_rope.h	/^	const_iterator begin() const {$/;"	f	class:rope
begin	stl_set.h	/^  iterator begin() const { return t.begin(); }$/;"	f	class:set
begin	stl_slist.h	/^  const_iterator begin() const { return const_iterator((list_node*)head.next);}$/;"	f	class:slist
begin	stl_slist.h	/^  iterator begin() { return iterator((list_node*)head.next); }$/;"	f	class:slist
begin	stl_tempbuf.h	/^  T* begin() { return buffer; }$/;"	f	class:temporary_buffer
begin	stl_tree.h	/^  const_iterator begin() const { return leftmost(); }$/;"	f	class:rb_tree
begin	stl_tree.h	/^  iterator begin() { return leftmost(); }$/;"	f	class:rb_tree
begin	stl_vector.h	/^  const_iterator begin() const { return start; }$/;"	f	class:vector
begin	stl_vector.h	/^  iterator begin() { return start; }$/;"	f	class:vector
bidirectional_iterator	stl_iterator.h	/^template <class T, class Distance> struct bidirectional_iterator {$/;"	s
bidirectional_iterator_tag	stl_iterator.h	/^struct bidirectional_iterator_tag : public forward_iterator_tag {};$/;"	s
binary_compose	stl_function.h	/^  binary_compose(const Operation1& x, const Operation2& y, $/;"	f	class:binary_compose
binary_compose	stl_function.h	/^class binary_compose$/;"	c
binary_function	stl_function.h	/^struct binary_function {$/;"	s
binary_negate	stl_function.h	/^  explicit binary_negate(const Predicate& x) : pred(x) {}$/;"	f	class:binary_negate
binary_negate	stl_function.h	/^class binary_negate $/;"	c
binary_search	stl_algo.h	/^bool binary_search(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f
binary_search	stl_algo.h	/^bool binary_search(ForwardIterator first, ForwardIterator last,$/;"	f
bind1st	stl_function.h	/^inline binder1st<Operation> bind1st(const Operation& op, const T& x) {$/;"	f
bind2nd	stl_function.h	/^inline binder2nd<Operation> bind2nd(const Operation& op, const T& x) {$/;"	f
binder1st	stl_function.h	/^  binder1st(const Operation& x,$/;"	f	class:binder1st
binder1st	stl_function.h	/^class binder1st$/;"	c
binder2nd	stl_function.h	/^  binder2nd(const Operation& x,$/;"	f	class:binder2nd
binder2nd	stl_function.h	/^class binder2nd$/;"	c
bit_alloc	stl_bvector.h	/^  unsigned int* bit_alloc(size_type n) {$/;"	f	class:vector
bit_vector	stl_bvector.h	/^typedef vector<bool, alloc> bit_vector;$/;"	t
bkt_num	stl_hashtable.h	/^  size_type bkt_num(const value_type& obj) const$/;"	f	class:hashtable
bkt_num	stl_hashtable.h	/^  size_type bkt_num(const value_type& obj, size_t n) const$/;"	f	class:hashtable
bkt_num_key	stl_hashtable.h	/^  size_type bkt_num_key(const key_type& key) const$/;"	f	class:hashtable
bkt_num_key	stl_hashtable.h	/^  size_type bkt_num_key(const key_type& key, size_t n) const$/;"	f	class:hashtable
bool	stl_config.h	/^    typedef int bool;$/;"	t
bucket_count	stl_hash_map.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_map
bucket_count	stl_hash_map.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_multimap
bucket_count	stl_hash_set.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_multiset
bucket_count	stl_hash_set.h	/^  size_type bucket_count() const { return rep.bucket_count(); }$/;"	f	class:hash_set
bucket_count	stl_hashtable.h	/^  size_type bucket_count() const { return buckets.size(); }$/;"	f	class:hashtable
buckets	stl_hashtable.h	/^  vector<node*,Alloc> buckets;$/;"	m	class:hashtable
buf_count	stl_rope.h	/^	size_t buf_count;$/;"	m	class:sequence_buffer
buf_end	stl_rope.h	/^    __GC_CONST charT * buf_end;$/;"	m	class:__rope_iterator_base
buf_ptr	ropeimpl.h	/^	charT * buf_ptr;$/;"	m	class:__rope_flatten_char_consumer
buf_ptr	stl_rope.h	/^    __GC_CONST charT * buf_ptr;$/;"	m	class:__rope_iterator_base
buf_start	stl_rope.h	/^    __GC_CONST charT * buf_start;$/;"	m	class:__rope_iterator_base
buffer	ropeimpl.h	/^	charT * buffer;$/;"	m	class:__rope_flatten_char_consumer
buffer	ropeimpl.h	/^	charT * buffer;$/;"	m	class:__rope_insert_char_consumer
buffer	stl_rope.h	/^	value_type buffer[buf_sz];$/;"	m	class:sequence_buffer
buffer	stl_tempbuf.h	/^  T* buffer;$/;"	m	class:temporary_buffer
buffer_size	stl_deque.h	/^  static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }$/;"	f	struct:__deque_iterator::__deque_iterator
buffer_size	stl_deque.h	/^  static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }$/;"	f	struct:__deque_iterator
buffer_size	stl_deque.h	/^  static size_type buffer_size() {$/;"	f	class:__deque_iterator::deque
bump_down	stl_bvector.h	/^  void bump_down() {$/;"	f	struct:__bit_const_iterator
bump_down	stl_bvector.h	/^  void bump_down() {$/;"	f	struct:__bit_iterator
bump_up	stl_bvector.h	/^  void bump_up() {$/;"	f	struct:__bit_const_iterator
bump_up	stl_bvector.h	/^  void bump_up() {$/;"	f	struct:__bit_iterator
c	stl_queue.h	/^  Sequence c;$/;"	m	class:priority_queue
c	stl_queue.h	/^  Sequence c;$/;"	m	class:queue
c	stl_stack.h	/^  Sequence c;$/;"	m	class:stack
c_str	ropeimpl.h	/^const charT * rope<charT,Alloc>::c_str() const {$/;"	f	class:rope
c_string	stl_rope.h	/^    __GC_CONST charT * c_string;$/;"	m	struct:__rope_RopeBase
capacity	stl_bvector.h	/^  size_type capacity() const {$/;"	f	class:vector
capacity	stl_rope.h	/^	    size_type capacity() const {$/;"	f	class:rope
capacity	stl_vector.h	/^  size_type capacity() const { return size_type(end_of_storage - begin()); }$/;"	f	class:vector
char_producer	stl_rope.h	/^class char_producer {$/;"	c
char_ptr_len	ropeimpl.h	/^inline size_t rope<charT,Alloc>::char_ptr_len(const charT *s)$/;"	f	class:rope
check	ropeimpl.h	/^void __rope_iterator<charT,Alloc>::check() {$/;"	f	class:__rope_iterator
chunk_alloc	stl_alloc.h	/^__default_alloc_template<threads, inst>::chunk_alloc(size_t size, int& nobjs)$/;"	f	class:__default_alloc_template
clear	stl_bvector.h	/^  void clear() { erase(begin(), end()); }$/;"	f	class:vector
clear	stl_deque.h	/^void deque<T, Alloc, BufSize>::clear() {$/;"	f	class:__deque_iterator::deque
clear	stl_hash_map.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_map
clear	stl_hash_map.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_multimap
clear	stl_hash_set.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_multiset
clear	stl_hash_set.h	/^  void clear() { rep.clear(); }$/;"	f	class:hash_set
clear	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::clear()$/;"	f	class:hashtable
clear	stl_list.h	/^void list<T, Alloc>::clear()$/;"	f	class:list
clear	stl_map.h	/^  void clear() { t.clear(); }$/;"	f	class:map
clear	stl_multimap.h	/^  void clear() { t.clear(); }$/;"	f	class:multimap
clear	stl_multiset.h	/^  void clear() { t.clear(); }$/;"	f	class:multiset
clear	stl_set.h	/^  void clear() { t.clear(); }$/;"	f	class:set
clear	stl_slist.h	/^  void clear() { erase_after(&head, 0); }$/;"	f	class:slist
clear	stl_tree.h	/^  void clear() {$/;"	f	class:rb_tree
clear	stl_vector.h	/^  void clear() { erase(begin(), end()); }$/;"	f	class:vector
client_data	stl_alloc.h	/^        char client_data[1];    \/* The client sees this.        *\/$/;"	m	union:__default_alloc_template::obj
clone_node	stl_tree.h	/^  link_type clone_node(link_type x) {$/;"	f	class:rb_tree
color	stl_tree.h	/^  color_type color; $/;"	m	struct:__rb_tree_node_base
color	stl_tree.h	/^  static color_type& color(base_ptr x) { return (color_type&)(link_type(x)->color); }$/;"	f	class:rb_tree
color	stl_tree.h	/^  static color_type& color(link_type x) { return (color_type&)(x->color); }$/;"	f	class:rb_tree
color_type	stl_tree.h	/^  typedef __rb_tree_color_type color_type;$/;"	t	class:rb_tree
color_type	stl_tree.h	/^  typedef __rb_tree_color_type color_type;$/;"	t	struct:__rb_tree_node_base
comp	stl_map.h	/^    Compare comp;$/;"	m	class:map::value_compare
comp	stl_multimap.h	/^    Compare comp;$/;"	m	class:multimap::value_compare
comp	stl_queue.h	/^  Compare comp;$/;"	m	class:priority_queue
compare	ropeimpl.h	/^rope<charT,Alloc>::compare (const RopeBase *left, const RopeBase *right)$/;"	f	class:rope
compare	stl_rope.h	/^	int compare(const rope &y) const {$/;"	f	class:rope
compose1	stl_function.h	/^inline unary_compose<Operation1, Operation2> compose1(const Operation1& op1, $/;"	f
compose2	stl_function.h	/^compose2(const Operation1& op1, const Operation2& op2, const Operation3& op3) {$/;"	f
concat	ropeimpl.h	/^rope<charT,Alloc>::concat(RopeBase * left, RopeBase * right)$/;"	f	class:rope
concat	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon2
concat_and_set_balanced	stl_rope.h	/^	static RopeBase * concat_and_set_balanced(RopeBase *left,$/;"	f	class:rope
concat_char_iter	ropeimpl.h	/^rope<charT,Alloc>::RopeBase * rope<charT,Alloc>::concat_char_iter$/;"	f	class:rope
concat_fn	stl_rope.h	/^	struct concat_fn$/;"	s	class:rope
const_address	defalloc.h	/^    const_pointer const_address(const_reference x) { $/;"	f	class:allocator
const_begin	stl_rope.h	/^	const_iterator const_begin() const {$/;"	f	class:rope
const_end	stl_rope.h	/^	const_iterator const_end() const {$/;"	f	class:rope
const_iterator	stl_bvector.h	/^  typedef __bit_const_iterator          const_iterator;$/;"	t	class:vector
const_iterator	stl_bvector.h	/^  typedef __bit_const_iterator const_iterator;$/;"	t	struct:__bit_const_iterator
const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T&, BufSiz>  const_iterator;$/;"	t	class:__deque_iterator::deque
const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*, BufSiz> const_iterator;$/;"	t	struct:__deque_iterator
const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*>          const_iterator;$/;"	t	class:__deque_iterator::deque
const_iterator	stl_deque.h	/^  typedef __deque_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__deque_iterator::__deque_iterator
const_iterator	stl_hash_map.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_map
const_iterator	stl_hash_map.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_multimap
const_iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_multiset
const_iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator const_iterator;$/;"	t	class:hash_set
const_iterator	stl_hashtable.h	/^          const_iterator;$/;"	t	struct:__hashtable_const_iterator
const_iterator	stl_hashtable.h	/^          const_iterator;$/;"	t	struct:__hashtable_iterator
const_iterator	stl_hashtable.h	/^  const_iterator;$/;"	t	class:hashtable
const_iterator	stl_list.h	/^  typedef __list_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:list
const_iterator	stl_list.h	/^  typedef __list_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__list_iterator
const_iterator	stl_map.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:map
const_iterator	stl_multimap.h	/^  typedef typename rep_type::const_iterator const_iterator; $/;"	t	class:multimap
const_iterator	stl_multiset.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:multiset
const_iterator	stl_rope.h	/^	typedef __rope_const_iterator<charT,Alloc> const_iterator;$/;"	t	class:rope
const_iterator	stl_set.h	/^  typedef typename rep_type::const_iterator const_iterator;$/;"	t	class:set
const_iterator	stl_slist.h	/^  typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	class:slist
const_iterator	stl_slist.h	/^  typedef __slist_iterator<T, const T&, const T*> const_iterator;$/;"	t	struct:__slist_iterator
const_iterator	stl_tree.h	/^          const_iterator;$/;"	t	class:rb_tree
const_iterator	stl_tree.h	/^  typedef __rb_tree_iterator<Value, const Value&, const Value*> const_iterator;$/;"	t	struct:__rb_tree_iterator
const_iterator	stl_vector.h	/^  typedef const value_type* const_iterator;$/;"	t	class:vector
const_mem_fun1_ref_t	stl_function.h	/^  explicit const_mem_fun1_ref_t(void (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_ref_t
const_mem_fun1_ref_t	stl_function.h	/^class const_mem_fun1_ref_t : public binary_function<T, A, S> {$/;"	c
const_mem_fun1_ref_t	stl_function.h	/^class const_mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {$/;"	c
const_mem_fun1_t	stl_function.h	/^  explicit const_mem_fun1_t(void (T::*pf)(A) const) : f(pf) {}$/;"	f	class:const_mem_fun1_t
const_mem_fun1_t	stl_function.h	/^class const_mem_fun1_t : public binary_function<const T*, A, S> {$/;"	c
const_mem_fun1_t	stl_function.h	/^class const_mem_fun1_t<void, T, A> : public binary_function<const T*, A, void> {$/;"	c
const_mem_fun_ref_t	stl_function.h	/^  explicit const_mem_fun_ref_t(void (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_ref_t
const_mem_fun_ref_t	stl_function.h	/^class const_mem_fun_ref_t : public unary_function<T, S> {$/;"	c
const_mem_fun_ref_t	stl_function.h	/^class const_mem_fun_ref_t<void, T> : public unary_function<T, void> {$/;"	c
const_mem_fun_t	stl_function.h	/^  explicit const_mem_fun_t(void (T::*pf)() const) : f(pf) {}$/;"	f	class:const_mem_fun_t
const_mem_fun_t	stl_function.h	/^class const_mem_fun_t : public unary_function<const T*, S> {$/;"	c
const_mem_fun_t	stl_function.h	/^class const_mem_fun_t<void, T> : public unary_function<const T*, void> {$/;"	c
const_pointer	defalloc.h	/^    typedef const T* const_pointer;$/;"	t	class:allocator
const_pointer	stl_bvector.h	/^  typedef const bool* const_pointer;$/;"	t	class:vector
const_pointer	stl_deque.h	/^  typedef const value_type* const_pointer;$/;"	t	class:__deque_iterator::deque
const_pointer	stl_hash_map.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_map
const_pointer	stl_hash_map.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_multimap
const_pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_multiset
const_pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer const_pointer;$/;"	t	class:hash_set
const_pointer	stl_hashtable.h	/^  typedef const value_type* const_pointer;$/;"	t	class:hashtable
const_pointer	stl_list.h	/^  typedef const value_type* const_pointer;$/;"	t	class:list
const_pointer	stl_map.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:map
const_pointer	stl_multimap.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:multimap
const_pointer	stl_multiset.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:multiset
const_pointer	stl_rope.h	/^	typedef const charT* const_pointer;$/;"	t	class:rope
const_pointer	stl_set.h	/^  typedef typename rep_type::const_pointer const_pointer;$/;"	t	class:set
const_pointer	stl_slist.h	/^  typedef const value_type* const_pointer;$/;"	t	class:slist
const_pointer	stl_tree.h	/^  typedef const value_type* const_pointer;$/;"	t	class:rb_tree
const_pointer	stl_vector.h	/^  typedef const value_type* const_pointer;$/;"	t	class:vector
const_rbegin	stl_rope.h	/^	const_reverse_iterator const_rbegin() const {$/;"	f	class:rope
const_reference	defalloc.h	/^    typedef const T& const_reference;$/;"	t	class:allocator
const_reference	stl_bvector.h	/^  typedef bool                 const_reference;$/;"	t	struct:__bit_const_iterator
const_reference	stl_bvector.h	/^  typedef bool const_reference;$/;"	t	class:vector
const_reference	stl_deque.h	/^  typedef const value_type& const_reference;$/;"	t	class:__deque_iterator::deque
const_reference	stl_hash_map.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_map
const_reference	stl_hash_map.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_multimap
const_reference	stl_hash_set.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_multiset
const_reference	stl_hash_set.h	/^  typedef typename ht::const_reference const_reference;$/;"	t	class:hash_set
const_reference	stl_hashtable.h	/^  typedef const value_type& const_reference;$/;"	t	class:hashtable
const_reference	stl_list.h	/^  typedef const value_type& const_reference;$/;"	t	class:list
const_reference	stl_map.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:map
const_reference	stl_multimap.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:multimap
const_reference	stl_multiset.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:multiset
const_reference	stl_queue.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:priority_queue
const_reference	stl_queue.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:queue
const_reference	stl_rope.h	/^	typedef charT const_reference;$/;"	t	class:rope
const_reference	stl_set.h	/^  typedef typename rep_type::const_reference const_reference;$/;"	t	class:set
const_reference	stl_slist.h	/^  typedef const value_type& const_reference;$/;"	t	class:slist
const_reference	stl_stack.h	/^  typedef typename Sequence::const_reference const_reference;$/;"	t	class:stack
const_reference	stl_tree.h	/^  typedef const value_type& const_reference;$/;"	t	class:rb_tree
const_reference	stl_vector.h	/^  typedef const value_type& const_reference;$/;"	t	class:vector
const_rend	stl_rope.h	/^	const_reverse_iterator const_rend() const {$/;"	f	class:rope
const_reverse_iterator	stl_bvector.h	/^                           difference_type> const_reverse_iterator;$/;"	t	class:vector
const_reverse_iterator	stl_bvector.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:vector
const_reverse_iterator	stl_deque.h	/^          const_reverse_iterator;$/;"	t	class:__deque_iterator::deque
const_reverse_iterator	stl_deque.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:__deque_iterator::deque
const_reverse_iterator	stl_list.h	/^  const_reverse_iterator;$/;"	t	class:list
const_reverse_iterator	stl_list.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:list
const_reverse_iterator	stl_map.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:map
const_reverse_iterator	stl_multimap.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:multimap
const_reverse_iterator	stl_multiset.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:multiset
const_reverse_iterator	stl_rope.h	/^				 difference_type>  const_reverse_iterator;$/;"	t	class:rope
const_reverse_iterator	stl_rope.h	/^        typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:rope
const_reverse_iterator	stl_set.h	/^  typedef typename rep_type::const_reverse_iterator const_reverse_iterator;$/;"	t	class:set
const_reverse_iterator	stl_tree.h	/^          const_reverse_iterator;$/;"	t	class:rb_tree
const_reverse_iterator	stl_tree.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:rb_tree
const_reverse_iterator	stl_vector.h	/^                           difference_type>  const_reverse_iterator;$/;"	t	class:vector
const_reverse_iterator	stl_vector.h	/^  typedef reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:vector
constant0	stl_function.h	/^inline constant_void_fun<Result> constant0(const Result& val)$/;"	f
constant1	stl_function.h	/^inline constant_unary_fun<Result,Result> constant1(const Result& val)$/;"	f
constant2	stl_function.h	/^inline constant_binary_fun<Result,Result,Result> constant2(const Result& val)$/;"	f
constant_binary_fun	stl_function.h	/^  constant_binary_fun(const Result& v) : val(v) {}$/;"	f	struct:constant_binary_fun
constant_binary_fun	stl_function.h	/^struct constant_binary_fun : public binary_function<Arg1, Arg2, Result> {$/;"	s
constant_unary_fun	stl_function.h	/^  constant_unary_fun(const Result& v) : val(v) {}$/;"	f	struct:constant_unary_fun
constant_unary_fun	stl_function.h	/^struct constant_unary_fun : public unary_function<Argument, Result> {$/;"	s
constant_void_fun	stl_function.h	/^  constant_void_fun(const result_type& v) : val(v) {}$/;"	f	struct:constant_void_fun
constant_void_fun	stl_function.h	/^struct constant_void_fun$/;"	s
construct	stl_construct.h	/^inline void construct(T1* p, const T2& value) {$/;"	f
container	stl_iterator.h	/^  Container* container;$/;"	m	class:back_insert_iterator
container	stl_iterator.h	/^  Container* container;$/;"	m	class:front_insert_iterator
container	stl_iterator.h	/^  Container* container;$/;"	m	class:insert_iterator
container	stl_rope.h	/^    rope<charT,Alloc>& container() { return *root_rope; }$/;"	f	class:__rope_iterator
copy	stl_algobase.h	/^inline OutputIterator copy(InputIterator first, InputIterator last,$/;"	f
copy	stl_algobase.h	/^inline char* copy(const char* first, const char* last, char* result) {$/;"	f
copy	stl_algobase.h	/^inline wchar_t* copy(const wchar_t* first, const wchar_t* last,$/;"	f
copy	stl_rope.h	/^	      size_type copy(charT *buffer, size_type n, size_type pos = 0)$/;"	f	class:rope
copy	stl_rope.h	/^	size_type copy(size_type pos, size_type n, charT *buffer) const {$/;"	f	class:rope
copy	stl_rope.h	/^	void copy(charT * buffer) const {$/;"	f	class:rope
copy_backward	stl_algobase.h	/^inline BidirectionalIterator2 copy_backward(BidirectionalIterator1 first, $/;"	f
copy_from	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::copy_from(const hashtable& ht)$/;"	f	class:hashtable
copy_max	stl_rope.h	/^	enum { copy_max = 23 };$/;"	e	enum:rope::__anon6
copy_n	stl_algobase.h	/^copy_n(InputIterator first, Size count,$/;"	f
count	ropeimpl.h	/^	size_t count;  \/\/ Number of nonmatching characters$/;"	m	class:__rope_find_char_char_consumer
count	stl_algo.h	/^count(InputIterator first, InputIterator last, const T& value) {$/;"	f
count	stl_algo.h	/^void count(InputIterator first, InputIterator last, const T& value,$/;"	f
count	stl_hash_map.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_map
count	stl_hash_map.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_multimap
count	stl_hash_set.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_multiset
count	stl_hash_set.h	/^  size_type count(const key_type& key) const { return rep.count(key); }$/;"	f	class:hash_set
count	stl_hashtable.h	/^  size_type count(const key_type& key) const$/;"	f	class:hashtable
count	stl_map.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:map
count	stl_multimap.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:multimap
count	stl_multiset.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:multiset
count	stl_set.h	/^  size_type count(const key_type& x) const { return t.count(x); }$/;"	f	class:set
count	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::count(const Key& k) const {$/;"	f	class:rb_tree
count_if	stl_algo.h	/^count_if(InputIterator first, InputIterator last, Predicate pred) {$/;"	f
count_if	stl_algo.h	/^void count_if(InputIterator first, InputIterator last, Predicate pred,$/;"	f
create_map_and_nodes	stl_deque.h	/^void deque<T, Alloc, BufSize>::create_map_and_nodes(size_type num_elements) {$/;"	f	class:__deque_iterator::deque
create_node	stl_list.h	/^  link_type create_node(const T& x) {$/;"	f	class:list
create_node	stl_slist.h	/^  static list_node* create_node(const value_type& x) {$/;"	f	class:slist
create_node	stl_tree.h	/^  link_type create_node(const value_type& x) {$/;"	f	class:rb_tree
crope	stl_rope.h	/^typedef rope<char, __ALLOC> crope;$/;"	t
cstrptr	stl_rope.h	/^	typedef __GC_CONST charT * cstrptr;$/;"	t	class:rope
cur	stl_deque.h	/^  T* cur;$/;"	m	struct:__deque_iterator::__deque_iterator
cur	stl_hashtable.h	/^  const node* cur;$/;"	m	struct:__hashtable_const_iterator
cur	stl_hashtable.h	/^  node* cur;$/;"	m	struct:__hashtable_iterator
current	stl_iterator.h	/^  BidirectionalIterator current;$/;"	m	class:reverse_bidirectional_iterator
current	stl_iterator.h	/^  Iterator current;$/;"	m	class:reverse_iterator
current	stl_iterator.h	/^  RandomAccessIterator current;$/;"	m	class:reverse_iterator
current	stl_rope.h	/^    charT current;$/;"	m	class:__rope_charT_ptr_proxy
current	stl_rope.h	/^    charT current;$/;"	m	class:__rope_charT_ref_proxy
current_pos	stl_rope.h	/^    size_t current_pos;$/;"	m	class:__rope_iterator_base
current_valid	stl_rope.h	/^    bool current_valid;$/;"	m	class:__rope_charT_ptr_proxy
current_valid	stl_rope.h	/^    bool current_valid;$/;"	m	class:__rope_charT_ref_proxy
data	stl_list.h	/^  T data;$/;"	m	struct:__list_node
data	stl_rope.h	/^    __GC_CONST charT* data;     \/* Not necessarily 0 terminated. *\/$/;"	m	struct:__rope_RopeLeaf
data	stl_slist.h	/^  T data;$/;"	m	struct:__slist_node
data_allocator	stl_bvector.h	/^  typedef simple_alloc<unsigned int, Alloc> data_allocator;$/;"	t	class:vector
data_allocator	stl_deque.h	/^  typedef simple_alloc<value_type, Alloc> data_allocator;$/;"	t	class:__deque_iterator::deque
data_allocator	stl_vector.h	/^  typedef simple_alloc<value_type, Alloc> data_allocator;$/;"	t	class:vector
data_type	stl_hash_map.h	/^  typedef T data_type;$/;"	t	class:hash_map
data_type	stl_hash_map.h	/^  typedef T data_type;$/;"	t	class:hash_multimap
data_type	stl_map.h	/^  typedef T data_type;$/;"	t	class:map
data_type	stl_multimap.h	/^  typedef T data_type;$/;"	t	class:multimap
deallocate	defalloc.h	/^    void deallocate(pointer p) { ::deallocate(p); }$/;"	f	class:allocator
deallocate	defalloc.h	/^inline void deallocate(T* buffer) {$/;"	f
deallocate	stl_alloc.h	/^    static void deallocate(T *p)$/;"	f	class:simple_alloc
deallocate	stl_alloc.h	/^    static void deallocate(T *p, size_t n)$/;"	f	class:simple_alloc
deallocate	stl_alloc.h	/^  static void deallocate(void *p, size_t n)$/;"	f	class:__default_alloc_template
deallocate	stl_alloc.h	/^static void deallocate(void *p, size_t \/* n *\/)$/;"	f	class:__malloc_alloc_template
deallocate	stl_alloc.h	/^static void deallocate(void *p, size_t n)$/;"	f	class:debug_alloc
deallocate	stl_bvector.h	/^  void deallocate() {$/;"	f	class:vector
deallocate	stl_vector.h	/^  void deallocate() {$/;"	f	class:vector
deallocate_node	stl_deque.h	/^  void deallocate_node(pointer n) {$/;"	f	class:__deque_iterator::deque
debug_alloc	stl_alloc.h	/^class debug_alloc {$/;"	c
decr	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::decr(size_t n) {$/;"	f	class:__rope_iterator_base
decr_refcount	stl_rope.h	/^	    size_t decr_refcount ()$/;"	f	struct:__rope_RopeBase
decr_refcount	stl_rope.h	/^            size_t decr_refcount ()$/;"	f	struct:__rope_RopeBase
decrement	stl_tree.h	/^  void decrement()$/;"	f	struct:__rb_tree_base_iterator
delete_c_str	stl_rope.h	/^	void delete_c_str () {$/;"	f	class:rope
delete_node	stl_hashtable.h	/^  void delete_node(node* n)$/;"	f	class:hashtable
delete_when_done	stl_rope.h	/^      bool delete_when_done;	\/\/ Char_producer is owned by the$/;"	m	struct:__rope_RopeFunction
depth	stl_rope.h	/^    unsigned char depth;$/;"	m	struct:__rope_RopeBase
deque	stl_deque.h	/^  deque()$/;"	f	class:__deque_iterator::deque
deque	stl_deque.h	/^  deque(InputIterator first, InputIterator last)$/;"	f	class:__deque_iterator::deque
deque	stl_deque.h	/^  deque(const deque& x)$/;"	f	class:__deque_iterator::deque
deque	stl_deque.h	/^  deque(const value_type* first, const value_type* last)$/;"	f	class:__deque_iterator::deque
deque	stl_deque.h	/^  deque(const_iterator first, const_iterator last)$/;"	f	class:__deque_iterator::deque
deque	stl_deque.h	/^  deque(int n, const value_type& value)$/;"	f	class:__deque_iterator::deque
deque	stl_deque.h	/^  deque(long n, const value_type& value)$/;"	f	class:__deque_iterator::deque
deque	stl_deque.h	/^  deque(size_type n, const value_type& value)$/;"	f	class:__deque_iterator::deque
deque	stl_deque.h	/^  explicit deque(size_type n)$/;"	f	class:__deque_iterator::deque
deque	stl_deque.h	/^class deque {$/;"	c	struct:__deque_iterator
destr_concat_char_iter	ropeimpl.h	/^::destr_concat_char_iter$/;"	f	class:rope
destr_concat_char_iter	stl_rope.h	/^	static RopeBase * destr_concat_char_iter(RopeBase * r,$/;"	f	class:rope
destr_leaf_concat_char_iter	ropeimpl.h	/^rope<charT,Alloc>::destr_leaf_concat_char_iter$/;"	f	class:rope
destroy	stl_construct.h	/^inline void destroy(ForwardIterator first, ForwardIterator last) {$/;"	f
destroy	stl_construct.h	/^inline void destroy(T* pointer) {$/;"	f
destroy	stl_construct.h	/^inline void destroy(char*, char*) {}$/;"	f
destroy	stl_construct.h	/^inline void destroy(wchar_t*, wchar_t*) {}$/;"	f
destroy_map_and_nodes	stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_map_and_nodes() {$/;"	f	class:__deque_iterator::deque
destroy_node	stl_list.h	/^  void destroy_node(link_type p) {$/;"	f	class:list
destroy_node	stl_slist.h	/^  static void destroy_node(list_node* node) {$/;"	f	class:slist
destroy_node	stl_tree.h	/^  void destroy_node(link_type p) {$/;"	f	class:rb_tree
destroy_nodes_at_back	stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_nodes_at_back(iterator after_finish) {$/;"	f	class:__deque_iterator::deque
destroy_nodes_at_front	stl_deque.h	/^void deque<T, Alloc, BufSize>::destroy_nodes_at_front(iterator before_start) {$/;"	f	class:__deque_iterator::deque
difference_type	defalloc.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:allocator
difference_type	stl_bvector.h	/^  typedef ptrdiff_t difference_type; $/;"	t	class:vector
difference_type	stl_deque.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:__deque_iterator::deque
difference_type	stl_deque.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__deque_iterator::__deque_iterator
difference_type	stl_hash_map.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_map
difference_type	stl_hash_map.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_multimap
difference_type	stl_hash_set.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_multiset
difference_type	stl_hash_set.h	/^  typedef typename ht::difference_type difference_type;$/;"	t	class:hash_set
difference_type	stl_hashtable.h	/^  typedef ptrdiff_t         difference_type;$/;"	t	class:hashtable
difference_type	stl_hashtable.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__hashtable_const_iterator
difference_type	stl_hashtable.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__hashtable_iterator
difference_type	stl_iterator.h	/^          difference_type;$/;"	t	class:reverse_iterator
difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	class:reverse_bidirectional_iterator
difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	class:reverse_iterator
difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	struct:bidirectional_iterator
difference_type	stl_iterator.h	/^  typedef Distance                   difference_type;$/;"	t	struct:random_access_iterator
difference_type	stl_iterator.h	/^  typedef Distance             difference_type;$/;"	t	struct:forward_iterator
difference_type	stl_iterator.h	/^  typedef Distance           difference_type;$/;"	t	class:istream_iterator
difference_type	stl_iterator.h	/^  typedef Distance           difference_type;$/;"	t	struct:input_iterator
difference_type	stl_iterator.h	/^  typedef Distance  difference_type;$/;"	t	struct:iterator
difference_type	stl_iterator.h	/^  typedef ptrdiff_t                  difference_type;$/;"	t	struct:iterator_traits
difference_type	stl_iterator.h	/^  typedef typename Iterator::difference_type   difference_type;$/;"	t	struct:iterator_traits
difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:back_insert_iterator
difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:front_insert_iterator
difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:insert_iterator
difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	class:ostream_iterator
difference_type	stl_iterator.h	/^  typedef void                difference_type;$/;"	t	struct:output_iterator
difference_type	stl_list.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:list
difference_type	stl_list.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__list_iterator
difference_type	stl_map.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:map
difference_type	stl_multimap.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:multimap
difference_type	stl_multiset.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:multiset
difference_type	stl_raw_storage_iter.h	/^  typedef void                difference_type;$/;"	t	class:raw_storage_iterator
difference_type	stl_rope.h	/^	typedef ptrdiff_t difference_type;$/;"	t	class:rope
difference_type	stl_set.h	/^  typedef typename rep_type::difference_type difference_type;$/;"	t	class:set
difference_type	stl_slist.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:slist
difference_type	stl_slist.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__slist_iterator_base
difference_type	stl_tree.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:rb_tree
difference_type	stl_tree.h	/^  typedef ptrdiff_t difference_type;$/;"	t	struct:__rb_tree_base_iterator
difference_type	stl_vector.h	/^  typedef ptrdiff_t difference_type;$/;"	t	class:vector
distance	stl_iterator.h	/^distance(InputIterator first, InputIterator last) {$/;"	f
distance	stl_iterator.h	/^inline void distance(InputIterator first, InputIterator last, Distance& n) {$/;"	f
distance_type	stl_deque.h	/^inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator
distance_type	stl_deque.h	/^inline ptrdiff_t* distance_type(const __deque_iterator<T, Ref, Ptr>&) {$/;"	f	struct:__deque_iterator
distance_type	stl_hashtable.h	/^distance_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
distance_type	stl_hashtable.h	/^distance_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
distance_type	stl_iterator.h	/^distance_type(const Iterator&) {$/;"	f
distance_type	stl_iterator.h	/^distance_type(const bidirectional_iterator<T, Distance>&) {$/;"	f
distance_type	stl_iterator.h	/^distance_type(const random_access_iterator<T, Distance>&) {$/;"	f
distance_type	stl_iterator.h	/^distance_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,$/;"	f
distance_type	stl_iterator.h	/^inline Distance* distance_type(const forward_iterator<T, Distance>&) {$/;"	f
distance_type	stl_iterator.h	/^inline Distance* distance_type(const input_iterator<T, Distance>&) {$/;"	f
distance_type	stl_iterator.h	/^inline Distance* distance_type(const istream_iterator<T, Distance>&) {$/;"	f
distance_type	stl_iterator.h	/^inline Distance* distance_type(const reverse_iterator<RandomAccessIterator, T,$/;"	f
distance_type	stl_iterator.h	/^inline ptrdiff_t* distance_type(const T*) { return (ptrdiff_t*)(0); }$/;"	f
distance_type	stl_list.h	/^distance_type(const __list_iterator<T, Ref, Ptr>&) {$/;"	f
distance_type	stl_slist.h	/^distance_type(const __slist_iterator_base&)$/;"	f
distance_type	stl_tree.h	/^distance_type(const __rb_tree_base_iterator&) {$/;"	f
divides	stl_function.h	/^struct divides : public binary_function<T, T, T> {$/;"	s
dump	ropeimpl.h	/^rope<charT,Alloc>::dump(RopeBase * r, int indent)$/;"	f	class:rope
dump	stl_rope.h	/^	void dump() {$/;"	f	class:rope
elems_in_bucket	stl_hash_map.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_map
elems_in_bucket	stl_hash_map.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_multimap
elems_in_bucket	stl_hash_set.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_multiset
elems_in_bucket	stl_hash_set.h	/^  size_type elems_in_bucket(size_type n) const$/;"	f	class:hash_set
elems_in_bucket	stl_hashtable.h	/^  size_type elems_in_bucket(size_type bucket) const$/;"	f	class:hashtable
empty	stl_bvector.h	/^  bool empty() const { return begin() == end(); }$/;"	f	class:vector
empty	stl_deque.h	/^  bool empty() const { return finish == start; }$/;"	f	class:__deque_iterator::deque
empty	stl_hash_map.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_map
empty	stl_hash_map.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_multimap
empty	stl_hash_set.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_multiset
empty	stl_hash_set.h	/^  bool empty() const { return rep.empty(); }$/;"	f	class:hash_set
empty	stl_hashtable.h	/^  bool empty() const { return size() == 0; }$/;"	f	class:hashtable
empty	stl_list.h	/^  bool empty() const { return node->next == node; }$/;"	f	class:list
empty	stl_map.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:map
empty	stl_multimap.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:multimap
empty	stl_multiset.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:multiset
empty	stl_queue.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:priority_queue
empty	stl_queue.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:queue
empty	stl_rope.h	/^	bool empty() const { return 0 == tree_ptr; }$/;"	f	class:rope
empty	stl_set.h	/^  bool empty() const { return t.empty(); }$/;"	f	class:set
empty	stl_slist.h	/^  bool empty() const { return head.next == 0; }$/;"	f	class:slist
empty	stl_stack.h	/^  bool empty() const { return c.empty(); }$/;"	f	class:stack
empty	stl_tree.h	/^  bool empty() const { return node_count == 0; }$/;"	f	class:rb_tree
empty	stl_vector.h	/^  bool empty() const { return begin() == end(); }$/;"	f	class:vector
empty_c_str	ropeimpl.h	/^template<class charT, class Alloc> charT rope<charT,Alloc>::empty_c_str[1];$/;"	m	class:rope
empty_c_str	stl_rope.h	/^	static charT empty_c_str[1];$/;"	m	class:rope
empty_initialize	stl_list.h	/^  void empty_initialize() { $/;"	f	class:list
end	stl_bvector.h	/^  const_iterator end() const { return finish; }$/;"	f	class:vector
end	stl_bvector.h	/^  iterator end() { return finish; }$/;"	f	class:vector
end	stl_deque.h	/^  const_iterator end() const { return finish; }$/;"	f	class:__deque_iterator::deque
end	stl_deque.h	/^  iterator end() { return finish; }$/;"	f	class:__deque_iterator::deque
end	stl_hash_map.h	/^  const_iterator end() const { return rep.end(); }$/;"	f	class:hash_map
end	stl_hash_map.h	/^  const_iterator end() const { return rep.end(); }$/;"	f	class:hash_multimap
end	stl_hash_map.h	/^  iterator end() { return rep.end(); }$/;"	f	class:hash_map
end	stl_hash_map.h	/^  iterator end() { return rep.end(); }$/;"	f	class:hash_multimap
end	stl_hash_set.h	/^  iterator end() const { return rep.end(); }$/;"	f	class:hash_multiset
end	stl_hash_set.h	/^  iterator end() const { return rep.end(); }$/;"	f	class:hash_set
end	stl_hashtable.h	/^  const_iterator end() const { return const_iterator(0, this); }$/;"	f	class:hashtable
end	stl_hashtable.h	/^  iterator end() { return iterator(0, this); }$/;"	f	class:hashtable
end	stl_list.h	/^  const_iterator end() const { return node; }$/;"	f	class:list
end	stl_list.h	/^  iterator end() { return node; }$/;"	f	class:list
end	stl_map.h	/^  const_iterator end() const { return t.end(); }$/;"	f	class:map
end	stl_map.h	/^  iterator end() { return t.end(); }$/;"	f	class:map
end	stl_multimap.h	/^  const_iterator end() const { return t.end(); }$/;"	f	class:multimap
end	stl_multimap.h	/^  iterator end() { return t.end(); }$/;"	f	class:multimap
end	stl_multiset.h	/^  iterator end() const { return t.end(); }$/;"	f	class:multiset
end	stl_rope.h	/^	    const_iterator end() { return const_end(); }$/;"	f	class:rope
end	stl_rope.h	/^	    iterator end() { return mutable_end(); }$/;"	f	class:rope
end	stl_rope.h	/^	const_iterator end() const {$/;"	f	class:rope
end	stl_set.h	/^  iterator end() const { return t.end(); }$/;"	f	class:set
end	stl_slist.h	/^  const_iterator end() const { return const_iterator(0); }$/;"	f	class:slist
end	stl_slist.h	/^  iterator end() { return iterator(0); }$/;"	f	class:slist
end	stl_tempbuf.h	/^  T* end() { return buffer + len; }$/;"	f	class:temporary_buffer
end	stl_tree.h	/^  const_iterator end() const { return header; }$/;"	f	class:rb_tree
end	stl_tree.h	/^  iterator end() { return header; }$/;"	f	class:rb_tree
end	stl_vector.h	/^  const_iterator end() const { return finish; }$/;"	f	class:vector
end	stl_vector.h	/^  iterator end() { return finish; }$/;"	f	class:vector
end_free	stl_alloc.h	/^  static char *end_free;$/;"	m	class:__default_alloc_template
end_free	stl_alloc.h	/^char *__default_alloc_template<threads, inst>::end_free = 0;$/;"	m	class:__default_alloc_template
end_marker	stl_iterator.h	/^  bool end_marker;$/;"	m	class:istream_iterator
end_of_storage	stl_bvector.h	/^  unsigned int* end_of_storage;$/;"	m	class:vector
end_of_storage	stl_vector.h	/^  iterator end_of_storage;$/;"	m	class:vector
equal	stl_algobase.h	/^inline bool equal(InputIterator1 first1, InputIterator1 last1,$/;"	f
equal_range	stl_algo.h	/^equal_range(ForwardIterator first, ForwardIterator last, const T& value) {$/;"	f
equal_range	stl_algo.h	/^equal_range(ForwardIterator first, ForwardIterator last, const T& value,$/;"	f
equal_range	stl_hash_map.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const$/;"	f	class:hash_map
equal_range	stl_hash_map.h	/^  pair<const_iterator, const_iterator> equal_range(const key_type& key) const$/;"	f	class:hash_multimap
equal_range	stl_hash_map.h	/^  pair<iterator, iterator> equal_range(const key_type& key)$/;"	f	class:hash_map
equal_range	stl_hash_map.h	/^  pair<iterator, iterator> equal_range(const key_type& key)$/;"	f	class:hash_multimap
equal_range	stl_hash_set.h	/^  pair<iterator, iterator> equal_range(const key_type& key) const$/;"	f	class:hash_multiset
equal_range	stl_hash_set.h	/^  pair<iterator, iterator> equal_range(const key_type& key) const$/;"	f	class:hash_set
equal_range	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key) const$/;"	f	class:hashtable
equal_range	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::equal_range(const key_type& key)$/;"	f	class:hashtable
equal_range	stl_map.h	/^  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {$/;"	f	class:map
equal_range	stl_map.h	/^  pair<iterator,iterator> equal_range(const key_type& x) {$/;"	f	class:map
equal_range	stl_multimap.h	/^   pair<iterator,iterator> equal_range(const key_type& x) {$/;"	f	class:multimap
equal_range	stl_multimap.h	/^  pair<const_iterator,const_iterator> equal_range(const key_type& x) const {$/;"	f	class:multimap
equal_range	stl_multiset.h	/^  pair<iterator,iterator> equal_range(const key_type& x) const {$/;"	f	class:multiset
equal_range	stl_set.h	/^  pair<iterator,iterator> equal_range(const key_type& x) const {$/;"	f	class:set
equal_range	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::equal_range(const Key& k) {$/;"	f	class:rb_tree
equal_range	stl_tree.h	/^rb_tree<Key, Value, KoV, Compare, Alloc>::equal_range(const Key& k) const {$/;"	f	class:rb_tree
equal_to	stl_function.h	/^struct equal_to : public binary_function<T, T, bool> {$/;"	s
equals	stl_hashtable.h	/^  key_equal equals;$/;"	m	class:hashtable
erase	stl_bvector.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:vector
erase	stl_bvector.h	/^  iterator erase(iterator position) {$/;"	f	class:vector
erase	stl_deque.h	/^  iterator erase(iterator pos) {$/;"	f	class:__deque_iterator::deque
erase	stl_deque.h	/^deque<T, Alloc, BufSize>::erase(iterator first, iterator last) {$/;"	f	class:__deque_iterator::deque
erase	stl_hash_map.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_map
erase	stl_hash_map.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_multimap
erase	stl_hash_map.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_map
erase	stl_hash_map.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_multimap
erase	stl_hash_map.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_map
erase	stl_hash_map.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_multimap
erase	stl_hash_set.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_multiset
erase	stl_hash_set.h	/^  size_type erase(const key_type& key) {return rep.erase(key); }$/;"	f	class:hash_set
erase	stl_hash_set.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_multiset
erase	stl_hash_set.h	/^  void erase(iterator f, iterator l) { rep.erase(f, l); }$/;"	f	class:hash_set
erase	stl_hash_set.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_multiset
erase	stl_hash_set.h	/^  void erase(iterator it) { rep.erase(it); }$/;"	f	class:hash_set
erase	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const const_iterator& it)$/;"	f	class:hashtable
erase	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const key_type& key)$/;"	f	class:hashtable
erase	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase(const_iterator first,$/;"	f	class:hashtable
erase	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase(const iterator& it)$/;"	f	class:hashtable
erase	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase(iterator first, iterator last)$/;"	f	class:hashtable
erase	stl_list.h	/^  iterator erase(iterator position) {$/;"	f	class:list
erase	stl_list.h	/^list<T,Alloc>::iterator list<T, Alloc>::erase(iterator first, iterator last) {$/;"	f	class:list
erase	stl_map.h	/^  size_type erase(const key_type& x) { return t.erase(x); }$/;"	f	class:map
erase	stl_map.h	/^  void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:map
erase	stl_map.h	/^  void erase(iterator position) { t.erase(position); }$/;"	f	class:map
erase	stl_multimap.h	/^  size_type erase(const key_type& x) { return t.erase(x); }$/;"	f	class:multimap
erase	stl_multimap.h	/^  void erase(iterator first, iterator last) { t.erase(first, last); }$/;"	f	class:multimap
erase	stl_multimap.h	/^  void erase(iterator position) { t.erase(position); }$/;"	f	class:multimap
erase	stl_multiset.h	/^  size_type erase(const key_type& x) { $/;"	f	class:multiset
erase	stl_multiset.h	/^  void erase(iterator first, iterator last) { $/;"	f	class:multiset
erase	stl_multiset.h	/^  void erase(iterator position) { $/;"	f	class:multiset
erase	stl_rope.h	/^	iterator erase(const iterator &p, const iterator &q) {$/;"	f	class:rope
erase	stl_rope.h	/^	void erase(size_t p) {$/;"	f	class:rope
erase	stl_rope.h	/^	void erase(size_t p, size_t n) {$/;"	f	class:rope
erase	stl_rope.h	/^        iterator erase(const iterator &p) {$/;"	f	class:rope
erase	stl_set.h	/^  size_type erase(const key_type& x) { $/;"	f	class:set
erase	stl_set.h	/^  void erase(iterator first, iterator last) { $/;"	f	class:set
erase	stl_set.h	/^  void erase(iterator position) { $/;"	f	class:set
erase	stl_slist.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:slist
erase	stl_slist.h	/^  iterator erase(iterator pos) {$/;"	f	class:slist
erase	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key& x) {$/;"	f	class:rb_tree
erase	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator position) {$/;"	f	class:rb_tree
erase	stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(const Key* first, $/;"	f	class:rb_tree
erase	stl_tree.h	/^void rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::erase(iterator first, $/;"	f	class:rb_tree
erase	stl_vector.h	/^  iterator erase(iterator first, iterator last) {$/;"	f	class:vector
erase	stl_vector.h	/^  iterator erase(iterator position) {$/;"	f	class:vector
erase_after	stl_slist.h	/^  iterator erase_after(iterator before_first, iterator last) {$/;"	f	class:slist
erase_after	stl_slist.h	/^  iterator erase_after(iterator pos) {$/;"	f	class:slist
erase_after	stl_slist.h	/^  list_node_base* erase_after(list_node_base* before_first,$/;"	f	class:slist
erase_after	stl_slist.h	/^  list_node_base* erase_after(list_node_base* pos) {$/;"	f	class:slist
erase_bucket	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, node* last)$/;"	f	class:hashtable
erase_bucket	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::erase_bucket(const size_type n, $/;"	f	class:hashtable
explicit	stl_config.h	181;"	d
extra	stl_alloc.h	/^enum {extra = 8};       \/\/ Size of space used to store size.  Note$/;"	e	enum:debug_alloc::__anon7
f	stl_function.h	/^  S (T::*f)() const;$/;"	m	class:const_mem_fun_ref_t
f	stl_function.h	/^  S (T::*f)() const;$/;"	m	class:const_mem_fun_t
f	stl_function.h	/^  S (T::*f)();$/;"	m	class:mem_fun_ref_t
f	stl_function.h	/^  S (T::*f)();$/;"	m	class:mem_fun_t
f	stl_function.h	/^  S (T::*f)(A) const;$/;"	m	class:const_mem_fun1_ref_t
f	stl_function.h	/^  S (T::*f)(A) const;$/;"	m	class:const_mem_fun1_t
f	stl_function.h	/^  S (T::*f)(A);$/;"	m	class:mem_fun1_ref_t
f	stl_function.h	/^  S (T::*f)(A);$/;"	m	class:mem_fun1_t
f	stl_function.h	/^  void (T::*f)() const;$/;"	m	class:const_mem_fun_ref_t
f	stl_function.h	/^  void (T::*f)() const;$/;"	m	class:const_mem_fun_t
f	stl_function.h	/^  void (T::*f)();$/;"	m	class:mem_fun_ref_t
f	stl_function.h	/^  void (T::*f)();$/;"	m	class:mem_fun_t
f	stl_function.h	/^  void (T::*f)(A) const;$/;"	m	class:const_mem_fun1_ref_t
f	stl_function.h	/^  void (T::*f)(A) const;$/;"	m	class:const_mem_fun1_t
f	stl_function.h	/^  void (T::*f)(A);$/;"	m	class:mem_fun1_ref_t
f	stl_function.h	/^  void (T::*f)(A);$/;"	m	class:mem_fun1_t
false	stl_config.h	173;"	d
fetch	ropeimpl.h	/^rope<charT,Alloc>::fetch(RopeBase *r, size_type i)$/;"	f	class:rope
fetch_ptr	ropeimpl.h	/^rope<charT,Alloc>::fetch_ptr(RopeBase *r, size_type i)$/;"	f	class:rope
fill	stl_algobase.h	/^void fill(ForwardIterator first, ForwardIterator last, const T& value) {$/;"	f
fill_initialize	stl_deque.h	/^void deque<T, Alloc, BufSize>::fill_initialize(size_type n,$/;"	f	class:__deque_iterator::deque
fill_initialize	stl_list.h	/^  void fill_initialize(size_type n, const T& value) {$/;"	f	class:list
fill_initialize	stl_slist.h	/^  void fill_initialize(size_type n, const value_type& x) {$/;"	f	class:slist
fill_initialize	stl_vector.h	/^  void fill_initialize(size_type n, const T& value) {$/;"	f	class:vector
fill_n	stl_algobase.h	/^OutputIterator fill_n(OutputIterator first, Size n, const T& value) {$/;"	f
find	ropeimpl.h	/^rope<charT,Alloc>::find(charT pattern, size_t start) const$/;"	f	class:rope
find	stl_algo.h	/^InputIterator find(InputIterator first, InputIterator last, const T& value) {$/;"	f
find	stl_hash_map.h	/^  const_iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_map
find	stl_hash_map.h	/^  const_iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_multimap
find	stl_hash_map.h	/^  iterator find(const key_type& key) { return rep.find(key); }$/;"	f	class:hash_map
find	stl_hash_map.h	/^  iterator find(const key_type& key) { return rep.find(key); }$/;"	f	class:hash_multimap
find	stl_hash_set.h	/^  iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_multiset
find	stl_hash_set.h	/^  iterator find(const key_type& key) const { return rep.find(key); }$/;"	f	class:hash_set
find	stl_hashtable.h	/^  const_iterator find(const key_type& key) const$/;"	f	class:hashtable
find	stl_hashtable.h	/^  iterator find(const key_type& key) $/;"	f	class:hashtable
find	stl_map.h	/^  const_iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:map
find	stl_map.h	/^  iterator find(const key_type& x) { return t.find(x); }$/;"	f	class:map
find	stl_multimap.h	/^  const_iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:multimap
find	stl_multimap.h	/^  iterator find(const key_type& x) { return t.find(x); }$/;"	f	class:multimap
find	stl_multiset.h	/^  iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:multiset
find	stl_rope.h	/^	size_type find(charT *s, size_type pos = 0) const {$/;"	f	class:rope
find	stl_set.h	/^  iterator find(const key_type& x) const { return t.find(x); }$/;"	f	class:set
find	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) const {$/;"	f	class:rb_tree
find	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::find(const Key& k) {$/;"	f	class:rb_tree
find_end	stl_algo.h	/^find_end(ForwardIterator1 first1, ForwardIterator1 last1, $/;"	f
find_first_of	stl_algo.h	/^InputIterator find_first_of(InputIterator first1, InputIterator last1,$/;"	f
find_if	stl_algo.h	/^InputIterator find_if(InputIterator first, InputIterator last,$/;"	f
find_or_insert	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::find_or_insert(const value_type& obj)$/;"	f	class:hashtable
finish	stl_bvector.h	/^  iterator finish;$/;"	m	class:vector
finish	stl_deque.h	/^  iterator finish;$/;"	m	class:__deque_iterator::deque
finish	stl_vector.h	/^  iterator finish;$/;"	m	class:vector
first	stl_deque.h	/^  T* first;$/;"	m	struct:__deque_iterator::__deque_iterator
first	stl_pair.h	/^  T1 first;$/;"	m	struct:pair
first_argument_type	stl_function.h	/^    typedef Arg1 first_argument_type;$/;"	t	struct:binary_function
first_type	stl_pair.h	/^  typedef T1 first_type;$/;"	t	struct:pair
flatten	ropeimpl.h	/^rope<charT,Alloc>::flatten(RopeBase * r, charT * buffer)$/;"	f	class:rope
flatten	ropeimpl.h	/^rope<charT,Alloc>::flatten(RopeBase * r,$/;"	f	class:rope
flip	stl_bvector.h	/^  void flip() { *p ^= mask; }$/;"	f	struct:__bit_reference
flush	stl_rope.h	/^	void flush() {$/;"	f	class:sequence_buffer
fn	stl_rope.h	/^    char_producer<charT>* fn;$/;"	m	struct:__rope_RopeFunction
fn_finalization_proc	ropeimpl.h	/^void __rope_RopeBase<charT,Alloc>::fn_finalization_proc(void * tree, void *)$/;"	f	class:__rope_RopeBase
for_each	stl_algo.h	/^Function for_each(InputIterator first, InputIterator last, Function f) {$/;"	f
forward_iterator	stl_iterator.h	/^template <class T, class Distance> struct forward_iterator {$/;"	s
forward_iterator_tag	stl_iterator.h	/^struct forward_iterator_tag : public input_iterator_tag {};$/;"	s
free_c_string	ropeimpl.h	/^inline void __rope_RopeBase<charT,Alloc>::free_c_string()$/;"	f	class:__rope_RopeBase
free_if_unref	stl_rope.h	/^	  static void free_if_unref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase
free_if_unref	stl_rope.h	/^	  static void free_if_unref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase
free_list	stl_alloc.h	/^    static obj * __VOLATILE free_list[]; $/;"	m	class:__default_alloc_template
free_list	stl_alloc.h	/^    static obj * __VOLATILE free_list[__NFREELISTS]; $/;"	m	class:__default_alloc_template
free_list	stl_alloc.h	/^__default_alloc_template<threads, inst> ::free_list[$/;"	m	class:__default_alloc_template
free_list_link	stl_alloc.h	/^        union obj * free_list_link;$/;"	m	union:__default_alloc_template::obj	typeref:union:__default_alloc_template::obj::obj
free_string	ropeimpl.h	/^inline void __rope_RopeBase<charT,Alloc>::free_string(charT* s, size_t n)$/;"	f	class:__rope_RopeBase
free_tree	ropeimpl.h	/^void __rope_RopeBase<charT,Alloc>::free_tree()$/;"	f	class:__rope_RopeBase
front	stl_bvector.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:vector
front	stl_bvector.h	/^  reference front() { return *begin(); }$/;"	f	class:vector
front	stl_deque.h	/^  const_reference front() const { return *start; }$/;"	f	class:__deque_iterator::deque
front	stl_deque.h	/^  reference front() { return *start; }$/;"	f	class:__deque_iterator::deque
front	stl_list.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:list
front	stl_list.h	/^  reference front() { return *begin(); }$/;"	f	class:list
front	stl_queue.h	/^  const_reference front() const { return c.front(); }$/;"	f	class:queue
front	stl_queue.h	/^  reference front() { return c.front(); }$/;"	f	class:queue
front	stl_rope.h	/^	charT front() const$/;"	f	class:rope
front	stl_slist.h	/^  const_reference front() const { return ((list_node*) head.next)->data; }$/;"	f	class:slist
front	stl_slist.h	/^  reference front() { return ((list_node*) head.next)->data; }$/;"	f	class:slist
front	stl_vector.h	/^  const_reference front() const { return *begin(); }$/;"	f	class:vector
front	stl_vector.h	/^  reference front() { return *begin(); }$/;"	f	class:vector
front_insert_iterator	stl_iterator.h	/^  explicit front_insert_iterator(Container& x) : container(&x) {}$/;"	f	class:front_insert_iterator
front_insert_iterator	stl_iterator.h	/^class front_insert_iterator {$/;"	c
front_inserter	stl_iterator.h	/^inline front_insert_iterator<Container> front_inserter(Container& x) {$/;"	f
function	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon2
generate	stl_algo.h	/^void generate(ForwardIterator first, ForwardIterator last, Generator gen) {$/;"	f
generate_n	stl_algo.h	/^OutputIterator generate_n(OutputIterator first, Size n, Generator gen) {$/;"	f
get_key	stl_hashtable.h	/^  ExtractKey get_key;$/;"	m	class:hashtable
get_node	stl_list.h	/^  link_type get_node() { return list_node_allocator::allocate(); }$/;"	f	class:list
get_node	stl_tree.h	/^  link_type get_node() { return rb_tree_node_allocator::allocate(); }$/;"	f	class:rb_tree
get_temporary_buffer	stl_tempbuf.h	/^pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t len, T*) {$/;"	f
greater	stl_function.h	/^struct greater : public binary_function<T, T, bool> {$/;"	s
greater_equal	stl_function.h	/^struct greater_equal : public binary_function<T, T, bool> {$/;"	s
has_trivial_assignment_operator	type_traits.h	/^   typedef __false_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits
has_trivial_assignment_operator	type_traits.h	/^   typedef __true_type    has_trivial_assignment_operator;$/;"	t	struct:__type_traits
has_trivial_copy_constructor	type_traits.h	/^   typedef __false_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits
has_trivial_copy_constructor	type_traits.h	/^   typedef __true_type    has_trivial_copy_constructor;$/;"	t	struct:__type_traits
has_trivial_default_constructor	type_traits.h	/^   typedef __false_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits
has_trivial_default_constructor	type_traits.h	/^   typedef __true_type    has_trivial_default_constructor;$/;"	t	struct:__type_traits
has_trivial_destructor	type_traits.h	/^   typedef __false_type    has_trivial_destructor;$/;"	t	struct:__type_traits
has_trivial_destructor	type_traits.h	/^   typedef __true_type    has_trivial_destructor;$/;"	t	struct:__type_traits
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<char*>$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<char> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<const char*>$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<int> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<long> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<short> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<signed char> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned char> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned int> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned long> {$/;"	s
hash	stl_hash_fun.h	/^__STL_TEMPLATE_NULL struct hash<unsigned short> {$/;"	s
hash	stl_hash_fun.h	/^template <class Key> struct hash { };$/;"	s
hash	stl_hashtable.h	/^  hasher hash;$/;"	m	class:hashtable
hash	stl_rope.h	/^__STL_TEMPLATE_NULL struct hash<crope>$/;"	s
hash	stl_rope.h	/^__STL_TEMPLATE_NULL struct hash<wrope>$/;"	s
hash_funct	stl_hash_map.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_map
hash_funct	stl_hash_map.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_multimap
hash_funct	stl_hash_set.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_multiset
hash_funct	stl_hash_set.h	/^  hasher hash_funct() const { return rep.hash_funct(); }$/;"	f	class:hash_set
hash_funct	stl_hashtable.h	/^  hasher hash_funct() const { return hash; }$/;"	f	class:hashtable
hash_map	stl_hash_map.h	/^  explicit hash_map(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l)$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l)$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l)$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^  hash_map(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_map
hash_map	stl_hash_map.h	/^class hash_map$/;"	c
hash_multimap	stl_hash_map.h	/^  explicit hash_multimap(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l)$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l)$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l)$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^  hash_multimap(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_multimap
hash_multimap	stl_hash_map.h	/^class hash_multimap$/;"	c
hash_multiset	stl_hash_set.h	/^  explicit hash_multiset(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l)$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l)$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l)$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^  hash_multiset(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_multiset
hash_multiset	stl_hash_set.h	/^class hash_multiset$/;"	c
hash_set	stl_hash_set.h	/^  explicit hash_set(size_type n) : rep(n, hasher(), key_equal()) {}$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set() : rep(100, hasher(), key_equal()) {}$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l)$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n)$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(InputIterator f, InputIterator l, size_type n,$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l)$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n)$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(const value_type* f, const value_type* l, size_type n,$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l)$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n)$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(const_iterator f, const_iterator l, size_type n,$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(size_type n, const hasher& hf) : rep(n, hf, key_equal()) {}$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^  hash_set(size_type n, const hasher& hf, const key_equal& eql)$/;"	f	class:hash_set
hash_set	stl_hash_set.h	/^class hash_set$/;"	c
hasher	stl_hash_map.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_map
hasher	stl_hash_map.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_multimap
hasher	stl_hash_set.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_multiset
hasher	stl_hash_set.h	/^  typedef typename ht::hasher hasher;$/;"	t	class:hash_set
hasher	stl_hashtable.h	/^  typedef HashFcn hasher;$/;"	t	class:hashtable
hashtable	stl_hashtable.h	/^          hashtable;$/;"	t	struct:__hashtable_const_iterator
hashtable	stl_hashtable.h	/^          hashtable;$/;"	t	struct:__hashtable_iterator
hashtable	stl_hashtable.h	/^  hashtable(const hashtable& ht)$/;"	f	class:hashtable
hashtable	stl_hashtable.h	/^  hashtable(size_type n,$/;"	f	class:hashtable
hashtable	stl_hashtable.h	/^class hashtable {$/;"	c
head	stl_slist.h	/^  list_node_base head;$/;"	m	class:slist
header	stl_tree.h	/^  link_type header;  $/;"	m	class:rb_tree
heap_size	stl_alloc.h	/^  static size_t heap_size;$/;"	m	class:__default_alloc_template
heap_size	stl_alloc.h	/^size_t __default_alloc_template<threads, inst>::heap_size = 0;$/;"	m	class:__default_alloc_template
ht	stl_hash_map.h	/^                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;$/;"	t	class:hash_map
ht	stl_hash_map.h	/^                    select1st<pair<const Key, T> >, EqualKey, Alloc> ht;$/;"	t	class:hash_multimap
ht	stl_hash_set.h	/^                    EqualKey, Alloc> ht;$/;"	t	class:hash_multiset
ht	stl_hash_set.h	/^                    EqualKey, Alloc> ht;$/;"	t	class:hash_set
ht	stl_hashtable.h	/^  const hashtable* ht;$/;"	m	struct:__hashtable_const_iterator
ht	stl_hashtable.h	/^  hashtable* ht;$/;"	m	struct:__hashtable_iterator
identity	stl_function.h	/^struct identity : public unary_function<T, T> {$/;"	s
identity_element	stl_function.h	/^template <class T> inline T identity_element(multiplies<T>) { return T(1); }$/;"	f
identity_element	stl_function.h	/^template <class T> inline T identity_element(plus<T>) { return T(0); }$/;"	f
identity_element	stl_rope.h	/^        friend rope identity_element(concat_fn) { return rope<charT,Alloc>(); }$/;"	f	class:rope
includes	stl_algo.h	/^bool includes(InputIterator1 first1, InputIterator1 last1,$/;"	f
incr	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::incr(size_t n) {$/;"	f	class:__rope_iterator_base
incr	stl_slist.h	/^  void incr() { node = node->next; }$/;"	f	struct:__slist_iterator_base
incr_refcount	stl_rope.h	/^	    void incr_refcount ()$/;"	f	struct:__rope_RopeBase
incr_refcount	stl_rope.h	/^	void incr_refcount () {}$/;"	f	struct:__rope_RopeBase
incr_refcount	stl_rope.h	/^            void incr_refcount ()$/;"	f	struct:__rope_RopeBase
increment	stl_tree.h	/^  void increment()$/;"	f	struct:__rb_tree_base_iterator
index	stl_rope.h	/^    size_t index() const { return current_pos; }$/;"	f	class:__rope_iterator_base
index1	stl_function.h	/^  size_t index1;$/;"	m	class:subtractive_rng
index2	stl_function.h	/^  size_t index2;$/;"	m	class:subtractive_rng
init	stl_tree.h	/^  void init() {$/;"	f	class:rb_tree
init_page_size	defalloc.h	/^    size_type init_page_size() { $/;"	f	class:allocator
init_refcount_lock	stl_rope.h	/^	    void init_refcount_lock() {$/;"	f	struct:__rope_RopeBase
init_refcount_lock	stl_rope.h	/^	    void init_refcount_lock() {}$/;"	f	struct:__rope_RopeBase
initial_map_size	stl_deque.h	/^  static size_type initial_map_size() { return 8; }$/;"	f	class:__deque_iterator::deque
initialize	stl_bvector.h	/^  void initialize(size_type n) {$/;"	f	class:vector
initialize	stl_function.h	/^  void initialize(unsigned int seed)$/;"	f	class:subtractive_rng
initialize_buckets	stl_hashtable.h	/^  void initialize_buckets(size_type n)$/;"	f	class:hashtable
initialize_buffer	stl_tempbuf.h	/^  void initialize_buffer(const T& val, __false_type) {$/;"	f	class:temporary_buffer
initialize_buffer	stl_tempbuf.h	/^  void initialize_buffer(const T&, __true_type) {}$/;"	f	class:temporary_buffer
initialize_range	stl_bvector.h	/^  void initialize_range(ForwardIterator first, ForwardIterator last,$/;"	f	class:vector
initialize_range	stl_bvector.h	/^  void initialize_range(InputIterator first, InputIterator last,$/;"	f	class:vector
inner_product	stl_numeric.h	/^T inner_product(InputIterator1 first1, InputIterator1 last1,$/;"	f
inplace_merge	stl_algo.h	/^inline void inplace_merge(BidirectionalIterator first,$/;"	f
input_iterator	stl_iterator.h	/^template <class T, class Distance> struct input_iterator {$/;"	s
input_iterator_tag	stl_iterator.h	/^struct input_iterator_tag {};$/;"	s
insert	stl_bvector.h	/^  iterator insert(iterator position, bool x = bool()) {$/;"	f	class:vector
insert	stl_bvector.h	/^  template <class InputIterator> void insert(iterator position,$/;"	f	class:vector
insert	stl_bvector.h	/^  void insert(iterator pos, int n, bool x)  { insert(pos, (size_type)n, x); }$/;"	f	class:vector
insert	stl_bvector.h	/^  void insert(iterator pos, long n, bool x) { insert(pos, (size_type)n, x); }$/;"	f	class:vector
insert	stl_bvector.h	/^  void insert(iterator position, const bool* first, const bool* last) {$/;"	f	class:vector
insert	stl_bvector.h	/^  void insert(iterator position, const_iterator first, $/;"	f	class:vector
insert	stl_bvector.h	/^  void insert(iterator position, size_type n, bool x) {$/;"	f	class:vector
insert	stl_deque.h	/^  iterator insert(iterator position) { return insert(position, value_type()); }$/;"	f	class:__deque_iterator::deque
insert	stl_deque.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:__deque_iterator::deque
insert	stl_deque.h	/^  void insert(iterator pos, InputIterator first, InputIterator last) {$/;"	f	class:__deque_iterator::deque
insert	stl_deque.h	/^  void insert(iterator pos, int n, const value_type& x) {$/;"	f	class:__deque_iterator::deque
insert	stl_deque.h	/^  void insert(iterator pos, long n, const value_type& x) {$/;"	f	class:__deque_iterator::deque
insert	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert(iterator pos,$/;"	f	class:__deque_iterator::deque
insert	stl_hash_map.h	/^  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }$/;"	f	class:hash_multimap
insert	stl_hash_map.h	/^  pair<iterator, bool> insert(const value_type& obj)$/;"	f	class:hash_map
insert	stl_hash_map.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }$/;"	f	class:hash_multimap
insert	stl_hash_map.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }$/;"	f	class:hash_map
insert	stl_hash_map.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_map
insert	stl_hash_map.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_multimap
insert	stl_hash_map.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }$/;"	f	class:hash_multimap
insert	stl_hash_map.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_unique(f, l); }$/;"	f	class:hash_map
insert	stl_hash_set.h	/^  iterator insert(const value_type& obj) { return rep.insert_equal(obj); }$/;"	f	class:hash_multiset
insert	stl_hash_set.h	/^  pair<iterator, bool> insert(const value_type& obj)$/;"	f	class:hash_set
insert	stl_hash_set.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_equal(f,l); }$/;"	f	class:hash_multiset
insert	stl_hash_set.h	/^  void insert(InputIterator f, InputIterator l) { rep.insert_unique(f,l); }$/;"	f	class:hash_set
insert	stl_hash_set.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_multiset
insert	stl_hash_set.h	/^  void insert(const value_type* f, const value_type* l) {$/;"	f	class:hash_set
insert	stl_hash_set.h	/^  void insert(const_iterator f, const_iterator l) { rep.insert_equal(f, l); }$/;"	f	class:hash_multiset
insert	stl_hash_set.h	/^  void insert(const_iterator f, const_iterator l) {rep.insert_unique(f, l); }$/;"	f	class:hash_set
insert	stl_list.h	/^  iterator insert(iterator position) { return insert(position, T()); }$/;"	f	class:list
insert	stl_list.h	/^  iterator insert(iterator position, const T& x) {$/;"	f	class:list
insert	stl_list.h	/^  void insert(iterator pos, int n, const T& x) {$/;"	f	class:list
insert	stl_list.h	/^  void insert(iterator pos, long n, const T& x) {$/;"	f	class:list
insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position, const T* first, const T* last) {$/;"	f	class:list
insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position, size_type n, const T& x) {$/;"	f	class:list
insert	stl_list.h	/^void list<T, Alloc>::insert(iterator position,$/;"	f	class:list
insert	stl_map.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:map
insert	stl_map.h	/^  pair<iterator,bool> insert(const value_type& x) { return t.insert_unique(x); }$/;"	f	class:map
insert	stl_map.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:map
insert	stl_map.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:map
insert	stl_map.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:map
insert	stl_multimap.h	/^  iterator insert(const value_type& x) { return t.insert_equal(x); }$/;"	f	class:multimap
insert	stl_multimap.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:multimap
insert	stl_multimap.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:multimap
insert	stl_multimap.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:multimap
insert	stl_multimap.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:multimap
insert	stl_multiset.h	/^  iterator insert(const value_type& x) { $/;"	f	class:multiset
insert	stl_multiset.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:multiset
insert	stl_multiset.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:multiset
insert	stl_multiset.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:multiset
insert	stl_multiset.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:multiset
insert	stl_rope.h	/^	iterator insert(const iterator& p ) $/;"	f	class:rope
insert	stl_rope.h	/^	iterator insert(const iterator& p, charT c) $/;"	f	class:rope
insert	stl_rope.h	/^	iterator insert(const iterator& p, const charT *c_string) $/;"	f	class:rope
insert	stl_rope.h	/^	iterator insert(const iterator& p, const charT *i, const charT *j)$/;"	f	class:rope
insert	stl_rope.h	/^	iterator insert(const iterator& p, const charT *i, size_t n)$/;"	f	class:rope
insert	stl_rope.h	/^	iterator insert(const iterator& p, const rope& r)$/;"	f	class:rope
insert	stl_rope.h	/^	iterator insert(const iterator& p, size_t n, charT c)$/;"	f	class:rope
insert	stl_rope.h	/^	iterator insert(const iterator& p,$/;"	f	class:rope
insert	stl_rope.h	/^	void insert(size_t p) {$/;"	f	class:rope
insert	stl_rope.h	/^	void insert(size_t p, charT c) {$/;"	f	class:rope
insert	stl_rope.h	/^	void insert(size_t p, const charT * c_string) {$/;"	f	class:rope
insert	stl_rope.h	/^	void insert(size_t p, const charT * i, size_t n) {$/;"	f	class:rope
insert	stl_rope.h	/^	void insert(size_t p, const charT *i, const charT *j) {$/;"	f	class:rope
insert	stl_rope.h	/^	void insert(size_t p, const const_iterator& i,$/;"	f	class:rope
insert	stl_rope.h	/^	void insert(size_t p, const iterator& i,$/;"	f	class:rope
insert	stl_rope.h	/^	void insert(size_t p, const rope& r) {$/;"	f	class:rope
insert	stl_rope.h	/^	void insert(size_t p, size_t n, charT c) {$/;"	f	class:rope
insert	stl_set.h	/^  iterator insert(iterator position, const value_type& x) {$/;"	f	class:set
insert	stl_set.h	/^  pair<iterator,bool> insert(const value_type& x) { $/;"	f	class:set
insert	stl_set.h	/^  void insert(InputIterator first, InputIterator last) {$/;"	f	class:set
insert	stl_set.h	/^  void insert(const value_type* first, const value_type* last) {$/;"	f	class:set
insert	stl_set.h	/^  void insert(const_iterator first, const_iterator last) {$/;"	f	class:set
insert	stl_slist.h	/^  iterator insert(iterator pos) {$/;"	f	class:slist
insert	stl_slist.h	/^  iterator insert(iterator pos, const value_type& x) {$/;"	f	class:slist
insert	stl_slist.h	/^  void insert(iterator pos, InIter first, InIter last) {$/;"	f	class:slist
insert	stl_slist.h	/^  void insert(iterator pos, const value_type* first, const value_type* last) {$/;"	f	class:slist
insert	stl_slist.h	/^  void insert(iterator pos, const_iterator first, const_iterator last) {$/;"	f	class:slist
insert	stl_slist.h	/^  void insert(iterator pos, int n, const value_type& x) {$/;"	f	class:slist
insert	stl_slist.h	/^  void insert(iterator pos, long n, const value_type& x) {$/;"	f	class:slist
insert	stl_slist.h	/^  void insert(iterator pos, size_type n, const value_type& x) {$/;"	f	class:slist
insert	stl_vector.h	/^  iterator insert(iterator position) { return insert(position, T()); }$/;"	f	class:vector
insert	stl_vector.h	/^  iterator insert(iterator position, const T& x) {$/;"	f	class:vector
insert	stl_vector.h	/^  void insert (iterator pos, int n, const T& x) {$/;"	f	class:vector
insert	stl_vector.h	/^  void insert (iterator pos, long n, const T& x) {$/;"	f	class:vector
insert	stl_vector.h	/^  void insert(iterator position, InputIterator first, InputIterator last) {$/;"	f	class:vector
insert	stl_vector.h	/^void vector<T, Alloc>::insert(iterator position, $/;"	f	class:vector
insert	stl_vector.h	/^void vector<T, Alloc>::insert(iterator position, size_type n, const T& x) {$/;"	f	class:vector
insert_after	stl_slist.h	/^  iterator insert_after(iterator pos) {$/;"	f	class:slist
insert_after	stl_slist.h	/^  iterator insert_after(iterator pos, const value_type& x) {$/;"	f	class:slist
insert_after	stl_slist.h	/^  void insert_after(iterator pos, InIter first, InIter last) {$/;"	f	class:slist
insert_after	stl_slist.h	/^  void insert_after(iterator pos, const_iterator first, const_iterator last) {$/;"	f	class:slist
insert_after	stl_slist.h	/^  void insert_after(iterator pos, int n, const value_type& x) {$/;"	f	class:slist
insert_after	stl_slist.h	/^  void insert_after(iterator pos, long n, const value_type& x) {$/;"	f	class:slist
insert_after	stl_slist.h	/^  void insert_after(iterator pos, size_type n, const value_type& x) {$/;"	f	class:slist
insert_after	stl_slist.h	/^  void insert_after(iterator pos,$/;"	f	class:slist
insert_aux	stl_bvector.h	/^  void insert_aux(iterator position, bool x) {$/;"	f	class:vector
insert_aux	stl_deque.h	/^deque<T, Alloc, BufSize>::insert_aux(iterator pos, const value_type& x) {$/;"	f	class:__deque_iterator::deque
insert_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::insert_aux(iterator pos,$/;"	f	class:__deque_iterator::deque
insert_aux	stl_vector.h	/^void vector<T, Alloc>::insert_aux(iterator position, const T& x) {$/;"	f	class:vector
insert_equal	stl_hashtable.h	/^  iterator insert_equal(const value_type& obj)$/;"	f	class:hashtable
insert_equal	stl_hashtable.h	/^  void insert_equal(ForwardIterator f, ForwardIterator l,$/;"	f	class:hashtable
insert_equal	stl_hashtable.h	/^  void insert_equal(InputIterator f, InputIterator l)$/;"	f	class:hashtable
insert_equal	stl_hashtable.h	/^  void insert_equal(InputIterator f, InputIterator l,$/;"	f	class:hashtable
insert_equal	stl_hashtable.h	/^  void insert_equal(const value_type* f, const value_type* l)$/;"	f	class:hashtable
insert_equal	stl_hashtable.h	/^  void insert_equal(const_iterator f, const_iterator l)$/;"	f	class:hashtable
insert_equal	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, Al>::insert_equal(const V* first, const V* last) {$/;"	f	class:rb_tree
insert_equal	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, Al>::insert_equal(const_iterator first,$/;"	f	class:rb_tree
insert_equal	stl_tree.h	/^rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_equal(iterator position,$/;"	f	class:rb_tree
insert_equal	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_equal(const Value& v)$/;"	f	class:rb_tree
insert_equal	stl_tree.h	/^void rb_tree<K, V, KoV, Cmp, Al>::insert_equal(II first, II last) {$/;"	f	class:rb_tree
insert_equal_noresize	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::insert_equal_noresize(const value_type& obj)$/;"	f	class:hashtable
insert_iterator	stl_iterator.h	/^  insert_iterator(Container& x, typename Container::iterator i) $/;"	f	class:insert_iterator
insert_iterator	stl_iterator.h	/^class insert_iterator {$/;"	c
insert_noresize	stl_hash_map.h	/^  iterator insert_noresize(const value_type& obj)$/;"	f	class:hash_multimap
insert_noresize	stl_hash_map.h	/^  pair<iterator, bool> insert_noresize(const value_type& obj)$/;"	f	class:hash_map
insert_noresize	stl_hash_set.h	/^  iterator insert_noresize(const value_type& obj)$/;"	f	class:hash_multiset
insert_noresize	stl_hash_set.h	/^  pair<iterator, bool> insert_noresize(const value_type& obj)$/;"	f	class:hash_set
insert_ostream	ropeimpl.h	/^	typedef ostream insert_ostream;$/;"	t	class:__rope_insert_char_consumer
insert_range	stl_bvector.h	/^  void insert_range(iterator pos,$/;"	f	class:vector
insert_range	stl_bvector.h	/^  void insert_range(iterator position,$/;"	f	class:vector
insert_unique	stl_hashtable.h	/^  pair<iterator, bool> insert_unique(const value_type& obj)$/;"	f	class:hashtable
insert_unique	stl_hashtable.h	/^  void insert_unique(ForwardIterator f, ForwardIterator l,$/;"	f	class:hashtable
insert_unique	stl_hashtable.h	/^  void insert_unique(InputIterator f, InputIterator l)$/;"	f	class:hashtable
insert_unique	stl_hashtable.h	/^  void insert_unique(InputIterator f, InputIterator l,$/;"	f	class:hashtable
insert_unique	stl_hashtable.h	/^  void insert_unique(const value_type* f, const value_type* l)$/;"	f	class:hashtable
insert_unique	stl_hashtable.h	/^  void insert_unique(const_iterator f, const_iterator l)$/;"	f	class:hashtable
insert_unique	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, A>::insert_unique(const V* first, const V* last) {$/;"	f	class:rb_tree
insert_unique	stl_tree.h	/^rb_tree<K, V, KoV, Cmp, A>::insert_unique(const_iterator first,$/;"	f	class:rb_tree
insert_unique	stl_tree.h	/^rb_tree<Key, Val, KeyOfValue, Compare, Alloc>::insert_unique(iterator position,$/;"	f	class:rb_tree
insert_unique	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::insert_unique(const Value& v)$/;"	f	class:rb_tree
insert_unique	stl_tree.h	/^void rb_tree<K, V, KoV, Cmp, Al>::insert_unique(II first, II last) {$/;"	f	class:rb_tree
insert_unique_noresize	stl_hashtable.h	/^hashtable<V, K, HF, Ex, Eq, A>::insert_unique_noresize(const value_type& obj)$/;"	f	class:hashtable
inserter	stl_iterator.h	/^inline insert_iterator<Container> inserter(Container& x, Iterator i) {$/;"	f
iota	stl_numeric.h	/^void iota(ForwardIterator first, ForwardIterator last, T value) {$/;"	f
is0	stl_rope.h	/^	static bool is0(charT c) { return c == __eos((charT *)0); }$/;"	f	class:rope
is_POD_type	type_traits.h	/^   typedef __false_type    is_POD_type;$/;"	t	struct:__type_traits
is_POD_type	type_traits.h	/^   typedef __true_type    is_POD_type;$/;"	t	struct:__type_traits
is_almost_balanced	stl_rope.h	/^	static bool is_almost_balanced(RopeBase *r)$/;"	f	class:rope
is_balanced	stl_rope.h	/^	static bool is_balanced(RopeBase *r)$/;"	f	class:rope
is_balanced	stl_rope.h	/^    bool is_balanced:8;$/;"	m	struct:__rope_RopeBase
is_heap	stl_algo.h	/^inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last)$/;"	f
is_heap	stl_algo.h	/^inline bool is_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
is_roughly_balanced	stl_rope.h	/^	static bool is_roughly_balanced(RopeBase *r)$/;"	f	class:rope
is_sorted	stl_algo.h	/^bool is_sorted(ForwardIterator first, ForwardIterator last)$/;"	f
is_sorted	stl_algo.h	/^bool is_sorted(ForwardIterator first, ForwardIterator last,$/;"	f
istream_iterator	stl_iterator.h	/^  istream_iterator() : stream(&cin), end_marker(false) {}$/;"	f	class:istream_iterator
istream_iterator	stl_iterator.h	/^  istream_iterator(istream& s) : stream(&s) { read(); }$/;"	f	class:istream_iterator
istream_iterator	stl_iterator.h	/^class istream_iterator {$/;"	c
iter	stl_iterator.h	/^  typename Container::iterator iter;$/;"	m	class:insert_iterator
iter	stl_raw_storage_iter.h	/^  ForwardIterator iter;$/;"	m	class:raw_storage_iterator
iter_swap	stl_algobase.h	/^inline void iter_swap(ForwardIterator1 a, ForwardIterator2 b) {$/;"	f
iterator	stl_bvector.h	/^  typedef __bit_iterator                iterator;$/;"	t	class:vector
iterator	stl_bvector.h	/^  typedef __bit_iterator iterator;$/;"	t	struct:__bit_iterator
iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*, BufSiz>              iterator;$/;"	t	class:__deque_iterator::deque
iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*, BufSiz>             iterator;$/;"	t	struct:__deque_iterator
iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*>                      iterator;$/;"	t	class:__deque_iterator::deque
iterator	stl_deque.h	/^  typedef __deque_iterator<T, T&, T*>             iterator;$/;"	t	struct:__deque_iterator::__deque_iterator
iterator	stl_hash_map.h	/^  typedef typename ht::iterator iterator;$/;"	t	class:hash_map
iterator	stl_hash_map.h	/^  typedef typename ht::iterator iterator;$/;"	t	class:hash_multimap
iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator iterator;$/;"	t	class:hash_multiset
iterator	stl_hash_set.h	/^  typedef typename ht::const_iterator iterator;$/;"	t	class:hash_set
iterator	stl_hashtable.h	/^          iterator;$/;"	t	struct:__hashtable_const_iterator
iterator	stl_hashtable.h	/^          iterator;$/;"	t	struct:__hashtable_iterator
iterator	stl_hashtable.h	/^  iterator;$/;"	t	class:hashtable
iterator	stl_iterator.h	/^struct iterator {$/;"	s
iterator	stl_list.h	/^  typedef __list_iterator<T, T&, T*>             iterator;$/;"	t	class:list
iterator	stl_list.h	/^  typedef __list_iterator<T, T&, T*>             iterator;$/;"	t	struct:__list_iterator
iterator	stl_map.h	/^  typedef typename rep_type::iterator iterator;$/;"	t	class:map
iterator	stl_multimap.h	/^  typedef typename rep_type::iterator iterator;$/;"	t	class:multimap
iterator	stl_multiset.h	/^  typedef typename rep_type::const_iterator iterator;$/;"	t	class:multiset
iterator	stl_rope.h	/^	typedef __rope_iterator<charT,Alloc> iterator;$/;"	t	class:rope
iterator	stl_set.h	/^  typedef typename rep_type::const_iterator iterator;$/;"	t	class:set
iterator	stl_slist.h	/^  typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	class:slist
iterator	stl_slist.h	/^  typedef __slist_iterator<T, T&, T*>             iterator;$/;"	t	struct:__slist_iterator
iterator	stl_tree.h	/^  typedef __rb_tree_iterator<Value, Value&, Value*>             iterator;$/;"	t	struct:__rb_tree_iterator
iterator	stl_tree.h	/^  typedef __rb_tree_iterator<value_type, reference, pointer> iterator;$/;"	t	class:rb_tree
iterator	stl_vector.h	/^  typedef value_type* iterator;$/;"	t	class:vector
iterator_base	stl_slist.h	/^  typedef __slist_iterator_base iterator_base;$/;"	t	class:slist
iterator_buf_len	stl_rope.h	/^    enum { iterator_buf_len = 15 };$/;"	e	enum:__rope_iterator_base::__anon5
iterator_category	stl_deque.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:__deque_iterator::__deque_iterator
iterator_category	stl_deque.h	/^iterator_category(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator
iterator_category	stl_deque.h	/^iterator_category(const __deque_iterator<T, Ref, Ptr>&) {$/;"	f	struct:__deque_iterator
iterator_category	stl_hashtable.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__hashtable_const_iterator
iterator_category	stl_hashtable.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__hashtable_iterator
iterator_category	stl_hashtable.h	/^iterator_category(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
iterator_category	stl_hashtable.h	/^iterator_category(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
iterator_category	stl_iterator.h	/^          iterator_category;$/;"	t	class:reverse_iterator
iterator_category	stl_iterator.h	/^  typedef Category  iterator_category;$/;"	t	struct:iterator
iterator_category	stl_iterator.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	class:reverse_bidirectional_iterator
iterator_category	stl_iterator.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:bidirectional_iterator
iterator_category	stl_iterator.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:forward_iterator
iterator_category	stl_iterator.h	/^  typedef input_iterator_tag iterator_category;$/;"	t	class:istream_iterator
iterator_category	stl_iterator.h	/^  typedef input_iterator_tag iterator_category;$/;"	t	struct:input_iterator
iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:back_insert_iterator
iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:front_insert_iterator
iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:insert_iterator
iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:ostream_iterator
iterator_category	stl_iterator.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	struct:output_iterator
iterator_category	stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	class:reverse_iterator
iterator_category	stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:iterator_traits
iterator_category	stl_iterator.h	/^  typedef random_access_iterator_tag iterator_category;$/;"	t	struct:random_access_iterator
iterator_category	stl_iterator.h	/^  typedef typename Iterator::iterator_category iterator_category;$/;"	t	struct:iterator_traits
iterator_category	stl_iterator.h	/^inline output_iterator_tag iterator_category(const output_iterator&) {$/;"	f
iterator_category	stl_iterator.h	/^inline random_access_iterator_tag iterator_category(const T*) {$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const Iterator&) {$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const back_insert_iterator<Container>&)$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const bidirectional_iterator<T, Distance>&) {$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const forward_iterator<T, Distance>&) {$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const front_insert_iterator<Container>&)$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const input_iterator<T, Distance>&) {$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const insert_iterator<Container>&)$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const istream_iterator<T, Distance>&) {$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const ostream_iterator<T>&) {$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const random_access_iterator<T, Distance>&) {$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const reverse_bidirectional_iterator<BidirectionalIterator,$/;"	f
iterator_category	stl_iterator.h	/^iterator_category(const reverse_iterator<RandomAccessIterator, T,$/;"	f
iterator_category	stl_list.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:__list_iterator
iterator_category	stl_list.h	/^iterator_category(const __list_iterator<T, Ref, Ptr>&) {$/;"	f
iterator_category	stl_raw_storage_iter.h	/^  typedef output_iterator_tag iterator_category;$/;"	t	class:raw_storage_iterator
iterator_category	stl_raw_storage_iter.h	/^iterator_category(const raw_storage_iterator<ForwardIterator, T>&)$/;"	f
iterator_category	stl_slist.h	/^  typedef forward_iterator_tag iterator_category;$/;"	t	struct:__slist_iterator_base
iterator_category	stl_slist.h	/^iterator_category(const __slist_iterator_base&)$/;"	f
iterator_category	stl_tree.h	/^  typedef bidirectional_iterator_tag iterator_category;$/;"	t	struct:__rb_tree_base_iterator
iterator_category	stl_tree.h	/^iterator_category(const __rb_tree_base_iterator&) {$/;"	f
iterator_traits	stl_iterator.h	/^struct iterator_traits {$/;"	s
iterator_traits	stl_iterator.h	/^struct iterator_traits<T*> {$/;"	s
iterator_traits	stl_iterator.h	/^struct iterator_traits<const T*> {$/;"	s
iterator_type	stl_iterator.h	/^  typedef Iterator iterator_type;$/;"	t	class:reverse_iterator
key	stl_tree.h	/^  static const Key& key(base_ptr x) { return KeyOfValue()(value(link_type(x)));} $/;"	f	class:rb_tree
key	stl_tree.h	/^  static const Key& key(link_type x) { return KeyOfValue()(value(x)); }$/;"	f	class:rb_tree
key_comp	stl_map.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:map
key_comp	stl_multimap.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:multimap
key_comp	stl_multiset.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:multiset
key_comp	stl_set.h	/^  key_compare key_comp() const { return t.key_comp(); }$/;"	f	class:set
key_comp	stl_tree.h	/^  Compare key_comp() const { return key_compare; }$/;"	f	class:rb_tree
key_compare	stl_map.h	/^  typedef Compare key_compare;$/;"	t	class:map
key_compare	stl_multimap.h	/^  typedef Compare key_compare;$/;"	t	class:multimap
key_compare	stl_multiset.h	/^  typedef Compare key_compare;$/;"	t	class:multiset
key_compare	stl_set.h	/^  typedef Compare key_compare;$/;"	t	class:set
key_compare	stl_tree.h	/^  Compare key_compare;$/;"	m	class:rb_tree
key_eq	stl_hash_map.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_map
key_eq	stl_hash_map.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_multimap
key_eq	stl_hash_set.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_multiset
key_eq	stl_hash_set.h	/^  key_equal key_eq() const { return rep.key_eq(); }$/;"	f	class:hash_set
key_eq	stl_hashtable.h	/^  key_equal key_eq() const { return equals; }$/;"	f	class:hashtable
key_equal	stl_hash_map.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_map
key_equal	stl_hash_map.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_multimap
key_equal	stl_hash_set.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_multiset
key_equal	stl_hash_set.h	/^  typedef typename ht::key_equal key_equal;$/;"	t	class:hash_set
key_equal	stl_hashtable.h	/^  typedef EqualKey key_equal;$/;"	t	class:hashtable
key_type	stl_hash_map.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_map
key_type	stl_hash_map.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_multimap
key_type	stl_hash_set.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_multiset
key_type	stl_hash_set.h	/^  typedef typename ht::key_type key_type;$/;"	t	class:hash_set
key_type	stl_hashtable.h	/^  typedef Key key_type;$/;"	t	class:hashtable
key_type	stl_map.h	/^  typedef Key key_type;$/;"	t	class:map
key_type	stl_multimap.h	/^  typedef Key key_type;$/;"	t	class:multimap
key_type	stl_multiset.h	/^  typedef Key key_type;$/;"	t	class:multiset
key_type	stl_set.h	/^  typedef Key key_type;$/;"	t	class:set
key_type	stl_tree.h	/^  typedef Key key_type;$/;"	t	class:rb_tree
last	stl_deque.h	/^  T* last;$/;"	m	struct:__deque_iterator::__deque_iterator
leaf	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon2
leaf_concat_char_iter	ropeimpl.h	/^rope<charT,Alloc>::leaf_concat_char_iter$/;"	f	class:rope
leaf_index	stl_rope.h	/^    int leaf_index;     \/\/ Last valid pos in path_end;$/;"	m	class:__rope_iterator_base
leaf_pos	stl_rope.h	/^    size_t leaf_pos;    \/\/ Starting position for current leaf$/;"	m	class:__rope_iterator_base
left	stl_rope.h	/^    __rope_RopeBase<charT,Alloc>* left;$/;"	m	struct:__rope_RopeConcatenation
left	stl_tree.h	/^  base_ptr left;$/;"	m	struct:__rb_tree_node_base
left	stl_tree.h	/^  static link_type& left(base_ptr x) { return (link_type&)(x->left); }$/;"	f	class:rb_tree
left	stl_tree.h	/^  static link_type& left(link_type x) { return (link_type&)(x->left); }$/;"	f	class:rb_tree
leftmost	stl_tree.h	/^  link_type& leftmost() const { return (link_type&) header->left; }$/;"	f	class:rb_tree
len	stl_tempbuf.h	/^  ptrdiff_t len;$/;"	m	class:temporary_buffer
length	stl_rope.h	/^	size_type length() const {$/;"	f	class:rope
less	stl_function.h	/^struct less : public binary_function<T, T, bool> {$/;"	s
less_equal	stl_function.h	/^struct less_equal : public binary_function<T, T, bool> {$/;"	s
lexicographical_compare	stl_algobase.h	/^bool lexicographical_compare(InputIterator1 first1, InputIterator1 last1,$/;"	f
lexicographical_compare	stl_algobase.h	/^inline bool lexicographical_compare(const char* first1, const char* last1,$/;"	f
lexicographical_compare	stl_algobase.h	/^lexicographical_compare(const unsigned char* first1,$/;"	f
lexicographical_compare_3way	stl_algobase.h	/^inline int lexicographical_compare_3way(const char* first1, const char* last1,$/;"	f
lexicographical_compare_3way	stl_algobase.h	/^int lexicographical_compare_3way(InputIterator1 first1, InputIterator1 last1,$/;"	f
lexicographical_compare_3way	stl_algobase.h	/^lexicographical_compare_3way(const unsigned char* first1,$/;"	f
link_type	stl_list.h	/^  typedef __list_node<T>* link_type;$/;"	t	struct:__list_iterator
link_type	stl_list.h	/^  typedef list_node* link_type;$/;"	t	class:list
link_type	stl_tree.h	/^  typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:__rb_tree_iterator
link_type	stl_tree.h	/^  typedef __rb_tree_node<Value>* link_type;$/;"	t	struct:__rb_tree_node
link_type	stl_tree.h	/^  typedef rb_tree_node* link_type;$/;"	t	class:rb_tree
list	stl_list.h	/^  explicit list(size_type n) { fill_initialize(n, T()); }$/;"	f	class:list
list	stl_list.h	/^  list() { empty_initialize(); }$/;"	f	class:list
list	stl_list.h	/^  list(InputIterator first, InputIterator last) {$/;"	f	class:list
list	stl_list.h	/^  list(const T* first, const T* last) { range_initialize(first, last); }$/;"	f	class:list
list	stl_list.h	/^  list(const list<T, Alloc>& x) {$/;"	f	class:list
list	stl_list.h	/^  list(const_iterator first, const_iterator last) {$/;"	f	class:list
list	stl_list.h	/^  list(int n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list
list	stl_list.h	/^  list(long n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list
list	stl_list.h	/^  list(size_type n, const T& value) { fill_initialize(n, value); }$/;"	f	class:list
list	stl_list.h	/^class list {$/;"	c
list_node	stl_list.h	/^  typedef __list_node<T> list_node;$/;"	t	class:list
list_node	stl_slist.h	/^  typedef __slist_node<T> list_node;$/;"	t	class:slist
list_node	stl_slist.h	/^  typedef __slist_node<T> list_node;$/;"	t	struct:__slist_iterator
list_node_allocator	stl_list.h	/^  typedef simple_alloc<list_node, Alloc> list_node_allocator;$/;"	t	class:list
list_node_allocator	stl_slist.h	/^  typedef simple_alloc<list_node, Alloc> list_node_allocator;$/;"	t	class:slist
list_node_base	stl_slist.h	/^  typedef __slist_node_base list_node_base;$/;"	t	class:slist
lock	stl_alloc.h	/^            lock() { __NODE_ALLOCATOR_LOCK; }$/;"	f	class:__default_alloc_template::lock
lock	stl_alloc.h	/^    class lock {$/;"	c	class:__default_alloc_template
logical_and	stl_function.h	/^struct logical_and : public binary_function<T, T, bool> {$/;"	s
logical_not	stl_function.h	/^struct logical_not : public unary_function<T, bool> {$/;"	s
logical_or	stl_function.h	/^struct logical_or : public binary_function<T, T, bool> {$/;"	s
lower_bound	stl_algo.h	/^inline ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last,$/;"	f
lower_bound	stl_map.h	/^  const_iterator lower_bound(const key_type& x) const {$/;"	f	class:map
lower_bound	stl_map.h	/^  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }$/;"	f	class:map
lower_bound	stl_multimap.h	/^  const_iterator lower_bound(const key_type& x) const {$/;"	f	class:multimap
lower_bound	stl_multimap.h	/^  iterator lower_bound(const key_type& x) {return t.lower_bound(x); }$/;"	f	class:multimap
lower_bound	stl_multiset.h	/^  iterator lower_bound(const key_type& x) const {$/;"	f	class:multiset
lower_bound	stl_set.h	/^  iterator lower_bound(const key_type& x) const {$/;"	f	class:set
lower_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) const {$/;"	f	class:rb_tree
lower_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::lower_bound(const Key& k) {$/;"	f	class:rb_tree
make_heap	stl_heap.h	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
make_heap	stl_heap.h	/^inline void make_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
make_pair	stl_pair.h	/^inline pair<T1, T2> make_pair(const T1& x, const T2& y) {$/;"	f
malloc_alloc	stl_alloc.h	/^typedef __malloc_alloc_template<0> malloc_alloc;$/;"	t
map	stl_deque.h	/^  map_pointer map;$/;"	m	class:__deque_iterator::deque
map	stl_map.h	/^  explicit map(const Compare& comp) : t(comp) {}$/;"	f	class:map
map	stl_map.h	/^  map() : t(Compare()) {}$/;"	f	class:map
map	stl_map.h	/^  map(InputIterator first, InputIterator last)$/;"	f	class:map
map	stl_map.h	/^  map(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:map
map	stl_map.h	/^  map(const map<Key, T, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:map
map	stl_map.h	/^  map(const value_type* first, const value_type* last)$/;"	f	class:map
map	stl_map.h	/^  map(const value_type* first, const value_type* last, const Compare& comp)$/;"	f	class:map
map	stl_map.h	/^  map(const_iterator first, const_iterator last)$/;"	f	class:map
map	stl_map.h	/^  map(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:map
map	stl_map.h	/^class map {$/;"	c
map_allocator	stl_deque.h	/^  typedef simple_alloc<pointer, Alloc> map_allocator;$/;"	t	class:__deque_iterator::deque
map_pointer	stl_deque.h	/^  typedef T** map_pointer;$/;"	t	struct:__deque_iterator::__deque_iterator
map_pointer	stl_deque.h	/^  typedef pointer* map_pointer;$/;"	t	class:__deque_iterator::deque
map_size	stl_deque.h	/^  size_type map_size;$/;"	m	class:__deque_iterator::deque
mapped_type	stl_hash_map.h	/^  typedef T mapped_type;$/;"	t	class:hash_map
mapped_type	stl_hash_map.h	/^  typedef T mapped_type;$/;"	t	class:hash_multimap
mapped_type	stl_map.h	/^  typedef T mapped_type;$/;"	t	class:map
mapped_type	stl_multimap.h	/^  typedef T mapped_type;$/;"	t	class:multimap
mask	stl_bvector.h	/^  unsigned int mask;$/;"	m	struct:__bit_reference
max	stl_algobase.h	/^inline const T& max(const T& a, const T& b) {$/;"	f
max	stl_algobase.h	/^inline const T& max(const T& a, const T& b, Compare comp) {$/;"	f
max	stl_algobase.h	83;"	d
max_bucket_count	stl_hash_map.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_map
max_bucket_count	stl_hash_map.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_multimap
max_bucket_count	stl_hash_set.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_multiset
max_bucket_count	stl_hash_set.h	/^  size_type max_bucket_count() const { return rep.max_bucket_count(); }$/;"	f	class:hash_set
max_bucket_count	stl_hashtable.h	/^  size_type max_bucket_count() const$/;"	f	class:hashtable
max_element	stl_algo.h	/^ForwardIterator max_element(ForwardIterator first, ForwardIterator last) {$/;"	f
max_element	stl_algo.h	/^ForwardIterator max_element(ForwardIterator first, ForwardIterator last,$/;"	f
max_rope_depth	stl_rope.h	/^    enum { max_rope_depth = 45 };$/;"	e	enum:__rope_RopeBase::__anon1
max_size	defalloc.h	/^    size_type max_size() const { $/;"	f	class:allocator
max_size	stl_bvector.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:vector
max_size	stl_deque.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:__deque_iterator::deque
max_size	stl_hash_map.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_map
max_size	stl_hash_map.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_multimap
max_size	stl_hash_set.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_multiset
max_size	stl_hash_set.h	/^  size_type max_size() const { return rep.max_size(); }$/;"	f	class:hash_set
max_size	stl_hashtable.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:hashtable
max_size	stl_list.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:list
max_size	stl_map.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:map
max_size	stl_multimap.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:multimap
max_size	stl_multiset.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:multiset
max_size	stl_rope.h	/^	size_type max_size() const {$/;"	f	class:rope
max_size	stl_set.h	/^  size_type max_size() const { return t.max_size(); }$/;"	f	class:set
max_size	stl_slist.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:slist
max_size	stl_tree.h	/^  size_type max_size() const { return size_type(-1); }$/;"	f	class:rb_tree
max_size	stl_vector.h	/^  size_type max_size() const { return size_type(-1) \/ sizeof(T); }$/;"	f	class:vector
maximum	stl_tree.h	/^  static base_ptr maximum(base_ptr x)$/;"	f	struct:__rb_tree_node_base
maximum	stl_tree.h	/^  static link_type maximum(link_type x) {$/;"	f	class:rb_tree
mem_fun1_ref_t	stl_function.h	/^  explicit mem_fun1_ref_t(void (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_ref_t
mem_fun1_ref_t	stl_function.h	/^class mem_fun1_ref_t : public binary_function<T, A, S> {$/;"	c
mem_fun1_ref_t	stl_function.h	/^class mem_fun1_ref_t<void, T, A> : public binary_function<T, A, void> {$/;"	c
mem_fun1_t	stl_function.h	/^  explicit mem_fun1_t(void (T::*pf)(A)) : f(pf) {}$/;"	f	class:mem_fun1_t
mem_fun1_t	stl_function.h	/^class mem_fun1_t : public binary_function<T*, A, S> {$/;"	c
mem_fun1_t	stl_function.h	/^class mem_fun1_t<void, T, A> : public binary_function<T*, A, void> {$/;"	c
mem_fun_ref_t	stl_function.h	/^  explicit mem_fun_ref_t(void (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_ref_t
mem_fun_ref_t	stl_function.h	/^class mem_fun_ref_t : public unary_function<T, S> {$/;"	c
mem_fun_ref_t	stl_function.h	/^class mem_fun_ref_t<void, T> : public unary_function<T, void> {$/;"	c
mem_fun_t	stl_function.h	/^  explicit mem_fun_t(void (T::*pf)()) : f(pf) {}$/;"	f	class:mem_fun_t
mem_fun_t	stl_function.h	/^class mem_fun_t : public unary_function<T*, S> {$/;"	c
mem_fun_t	stl_function.h	/^class mem_fun_t<void, T> : public unary_function<T*, void> {$/;"	c
merge	stl_algo.h	/^OutputIterator merge(InputIterator1 first1, InputIterator1 last1,$/;"	f
merge	stl_list.h	/^void list<T, Alloc>::merge(list<T, Alloc>& x) {$/;"	f	class:list
merge	stl_list.h	/^void list<T, Alloc>::merge(list<T, Alloc>& x, StrictWeakOrdering comp) {$/;"	f	class:list
merge	stl_slist.h	/^void slist<T,Alloc>::merge(slist<T,Alloc>& L)$/;"	f	class:slist
merge	stl_slist.h	/^void slist<T,Alloc>::merge(slist<T,Alloc>& L, StrictWeakOrdering comp)$/;"	f	class:slist
min	stl_algobase.h	/^inline const T& min(const T& a, const T& b) {$/;"	f
min	stl_algobase.h	/^inline const T& min(const T& a, const T& b, Compare comp) {$/;"	f
min	stl_algobase.h	82;"	d
min_element	stl_algo.h	/^ForwardIterator min_element(ForwardIterator first, ForwardIterator last) {$/;"	f
min_element	stl_algo.h	/^ForwardIterator min_element(ForwardIterator first, ForwardIterator last,$/;"	f
min_len	ropeimpl.h	/^rope<charT,Alloc>::min_len[__rope_RopeBase<charT,Alloc>::max_rope_depth + 1] = {$/;"	m	class:rope
min_len	stl_rope.h	/^	static const unsigned long min_len[RopeBase::max_rope_depth + 1];$/;"	m	class:rope
minimum	stl_tree.h	/^  static base_ptr minimum(base_ptr x)$/;"	f	struct:__rb_tree_node_base
minimum	stl_tree.h	/^  static link_type minimum(link_type x) { $/;"	f	class:rb_tree
minus	stl_function.h	/^struct minus : public binary_function<T, T, T> {$/;"	s
mismatch	stl_algobase.h	/^pair<InputIterator1, InputIterator2> mismatch(InputIterator1 first1,$/;"	f
modulus	stl_function.h	/^struct modulus : public binary_function<T, T, T> {$/;"	s
multimap	stl_multimap.h	/^  explicit multimap(const Compare& comp) : t(comp) { }$/;"	f	class:multimap
multimap	stl_multimap.h	/^  multimap() : t(Compare()) { }$/;"	f	class:multimap
multimap	stl_multimap.h	/^  multimap(InputIterator first, InputIterator last)$/;"	f	class:multimap
multimap	stl_multimap.h	/^  multimap(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:multimap
multimap	stl_multimap.h	/^  multimap(const multimap<Key, T, Compare, Alloc>& x) : t(x.t) { }$/;"	f	class:multimap
multimap	stl_multimap.h	/^  multimap(const value_type* first, const value_type* last)$/;"	f	class:multimap
multimap	stl_multimap.h	/^  multimap(const value_type* first, const value_type* last,$/;"	f	class:multimap
multimap	stl_multimap.h	/^  multimap(const_iterator first, const_iterator last)$/;"	f	class:multimap
multimap	stl_multimap.h	/^  multimap(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:multimap
multimap	stl_multimap.h	/^class multimap {$/;"	c
multiplies	stl_function.h	/^struct multiplies : public binary_function<T, T, T> {$/;"	s
multiset	stl_multiset.h	/^  explicit multiset(const Compare& comp) : t(comp) {}$/;"	f	class:multiset
multiset	stl_multiset.h	/^  multiset() : t(Compare()) {}$/;"	f	class:multiset
multiset	stl_multiset.h	/^  multiset(InputIterator first, InputIterator last)$/;"	f	class:multiset
multiset	stl_multiset.h	/^  multiset(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:multiset
multiset	stl_multiset.h	/^  multiset(const multiset<Key, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:multiset
multiset	stl_multiset.h	/^  multiset(const value_type* first, const value_type* last)$/;"	f	class:multiset
multiset	stl_multiset.h	/^  multiset(const value_type* first, const value_type* last,$/;"	f	class:multiset
multiset	stl_multiset.h	/^  multiset(const_iterator first, const_iterator last)$/;"	f	class:multiset
multiset	stl_multiset.h	/^  multiset(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:multiset
multiset	stl_multiset.h	/^class multiset {$/;"	c
mutable_begin	stl_rope.h	/^	iterator mutable_begin() {$/;"	f	class:rope
mutable_end	stl_rope.h	/^	iterator mutable_end() {$/;"	f	class:rope
mutable_rbegin	stl_rope.h	/^	reverse_iterator mutable_rbegin() {$/;"	f	class:rope
mutable_reference_at	stl_rope.h	/^	reference mutable_reference_at(size_type pos) {$/;"	f	class:rope
mutable_rend	stl_rope.h	/^	reverse_iterator mutable_rend() {$/;"	f	class:rope
my_rope	stl_rope.h	/^    typedef rope<charT,Alloc> my_rope;$/;"	t	class:__rope_charT_ref_proxy
my_rope	stl_rope.h	/^    typedef rope<charT,Alloc> my_rope;$/;"	t	struct:__rope_RopeBase
negate	stl_function.h	/^struct negate : public unary_function<T, T> {$/;"	s
new_elements_at_back	stl_deque.h	/^void deque<T, Alloc, BufSize>::new_elements_at_back(size_type new_elements) {$/;"	f	class:__deque_iterator::deque
new_elements_at_front	stl_deque.h	/^void deque<T, Alloc, BufSize>::new_elements_at_front(size_type new_elements) {$/;"	f	class:__deque_iterator::deque
new_node	stl_hashtable.h	/^  node* new_node(const value_type& obj)$/;"	f	class:hashtable
next	stl_hashtable.h	/^  __hashtable_node* next;$/;"	m	struct:__hashtable_node
next	stl_list.h	/^  void_pointer next;$/;"	m	struct:__list_node
next	stl_slist.h	/^  __slist_node_base* next;$/;"	m	struct:__slist_node_base
next_permutation	stl_algo.h	/^bool next_permutation(BidirectionalIterator first, BidirectionalIterator last,$/;"	f
next_permutation	stl_algo.h	/^bool next_permutation(BidirectionalIterator first,$/;"	f
next_size	stl_hashtable.h	/^  size_type next_size(size_type n) const { return __stl_next_prime(n); }$/;"	f	class:hashtable
node	stl_deque.h	/^  map_pointer node;$/;"	m	struct:__deque_iterator::__deque_iterator
node	stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	class:hashtable
node	stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	struct:__hashtable_const_iterator
node	stl_hashtable.h	/^  typedef __hashtable_node<Value> node;$/;"	t	struct:__hashtable_iterator
node	stl_list.h	/^  link_type node;$/;"	m	class:list
node	stl_list.h	/^  link_type node;$/;"	m	struct:__list_iterator
node	stl_slist.h	/^  __slist_node_base* node;$/;"	m	struct:__slist_iterator_base
node	stl_tree.h	/^  base_ptr node;$/;"	m	struct:__rb_tree_base_iterator
node_allocator	stl_hashtable.h	/^  typedef simple_alloc<node, Alloc> node_allocator;$/;"	t	class:hashtable
node_count	stl_tree.h	/^  size_type node_count; \/\/ keeps track of size of tree$/;"	m	class:rb_tree
not1	stl_function.h	/^inline unary_negate<Predicate> not1(const Predicate& pred) {$/;"	f
not2	stl_function.h	/^inline binary_negate<Predicate> not2(const Predicate& pred) {$/;"	f
not_equal_to	stl_function.h	/^struct not_equal_to : public binary_function<T, T, bool> {$/;"	s
nth_element	stl_algo.h	/^inline void nth_element(RandomAccessIterator first, RandomAccessIterator nth,$/;"	f
num_elements	stl_hashtable.h	/^  size_type num_elements;$/;"	m	class:hashtable
o	ropeimpl.h	/^	insert_ostream & o;$/;"	m	class:__rope_insert_char_consumer
obj	stl_alloc.h	/^  union obj {$/;"	u	class:__default_alloc_template
offset	stl_bvector.h	/^  unsigned int offset;$/;"	m	struct:__bit_const_iterator
offset	stl_bvector.h	/^  unsigned int offset;$/;"	m	struct:__bit_iterator
oom_malloc	stl_alloc.h	/^void * __malloc_alloc_template<inst>::oom_malloc(size_t n)$/;"	f	class:__malloc_alloc_template
oom_realloc	stl_alloc.h	/^void * __malloc_alloc_template<inst>::oom_realloc(void *p, size_t n)$/;"	f	class:__malloc_alloc_template
op	stl_function.h	/^  Operation op;$/;"	m	class:binder1st
op	stl_function.h	/^  Operation op;$/;"	m	class:binder2nd
op1	stl_function.h	/^  Operation1 op1;$/;"	m	class:binary_compose
op1	stl_function.h	/^  Operation1 op1;$/;"	m	class:unary_compose
op2	stl_function.h	/^  Operation2 op2;$/;"	m	class:binary_compose
op2	stl_function.h	/^  Operation2 op2;$/;"	m	class:unary_compose
op3	stl_function.h	/^  Operation3 op3;$/;"	m	class:binary_compose
operator !=	stl_bvector.h	/^  bool operator!=(const const_iterator& x) const {$/;"	f	struct:__bit_const_iterator
operator !=	stl_bvector.h	/^  bool operator!=(const iterator& x) const {$/;"	f	struct:__bit_iterator
operator !=	stl_deque.h	/^  bool operator!=(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque
operator !=	stl_deque.h	/^  bool operator!=(const self& x) const { return !(*this == x); }$/;"	f	struct:__deque_iterator::__deque_iterator
operator !=	stl_hashtable.h	/^  bool operator!=(const const_iterator& it) const { return cur != it.cur; }$/;"	f	struct:__hashtable_const_iterator
operator !=	stl_hashtable.h	/^  bool operator!=(const iterator& it) const { return cur != it.cur; }$/;"	f	struct:__hashtable_iterator
operator !=	stl_list.h	/^  bool operator!=(const self& x) const { return node != x.node; }$/;"	f	struct:__list_iterator
operator !=	stl_relops.h	/^inline bool operator!=(const T& x, const T& y) {$/;"	f
operator !=	stl_slist.h	/^  bool operator!=(const __slist_iterator_base& x) const {$/;"	f	struct:__slist_iterator_base
operator !=	stl_tree.h	/^inline bool operator!=(const __rb_tree_base_iterator& x,$/;"	f
operator &	ropeimpl.h	/^__rope_charT_ref_proxy<charT, Alloc>::operator& () const {$/;"	f	class:__rope_charT_ref_proxy
operator ()	ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n) {$/;"	f	class:__rope_find_char_char_consumer
operator ()	ropeimpl.h	/^	bool operator() (const charT* leaf, size_t n) {$/;"	f	class:__rope_flatten_char_consumer
operator ()	ropeimpl.h	/^bool __rope_insert_char_consumer<charT>::operator()$/;"	f	class:__rope_insert_char_consumer
operator ()	ropeimpl.h	/^inline bool __rope_insert_char_consumer<char>::operator()$/;"	f	class:__rope_insert_char_consumer
operator ()	ropeimpl.h	/^inline bool __rope_insert_char_consumer<wchar_t>::operator()$/;"	f	class:__rope_insert_char_consumer
operator ()	stl_algobase.h	/^  BidirectionalIterator2 operator()(BidirectionalIterator1 first, $/;"	f	struct:__copy_backward_dispatch
operator ()	stl_algobase.h	/^  OutputIterator operator()(InputIterator first, InputIterator last,$/;"	f	struct:__copy_dispatch
operator ()	stl_algobase.h	/^  T* operator()(T* first, T* last, T* result) {$/;"	f	struct:__copy_backward_dispatch
operator ()	stl_algobase.h	/^  T* operator()(T* first, T* last, T* result) {$/;"	f	struct:__copy_dispatch
operator ()	stl_algobase.h	/^  T* operator()(const T* first, const T* last, T* result) {$/;"	f	struct:__copy_backward_dispatch
operator ()	stl_algobase.h	/^  T* operator()(const T* first, const T* last, T* result) {$/;"	f	struct:__copy_dispatch
operator ()	stl_function.h	/^    Result operator()(Arg1 x, Arg2 y) const { return ptr(x, y); }$/;"	f	class:pointer_to_binary_function
operator ()	stl_function.h	/^    T operator()(const T& x) const { return -x; }$/;"	f	struct:negate
operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x % y; }$/;"	f	struct:modulus
operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x * y; }$/;"	f	struct:multiplies
operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x + y; }$/;"	f	struct:plus
operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x - y; }$/;"	f	struct:minus
operator ()	stl_function.h	/^    T operator()(const T& x, const T& y) const { return x \/ y; }$/;"	f	struct:divides
operator ()	stl_function.h	/^    bool operator()(const T& x) const { return !x; }$/;"	f	struct:logical_not
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x != y; }$/;"	f	struct:not_equal_to
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x && y; }$/;"	f	struct:logical_and
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x < y; }$/;"	f	struct:less
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x <= y; }$/;"	f	struct:less_equal
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x == y; }$/;"	f	struct:equal_to
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x > y; }$/;"	f	struct:greater
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x >= y; }$/;"	f	struct:greater_equal
operator ()	stl_function.h	/^    bool operator()(const T& x, const T& y) const { return x || y; }$/;"	f	struct:logical_or
operator ()	stl_function.h	/^  Arg1 operator()(const Arg1& x, const Arg2&) const { return x; }$/;"	f	struct:project1st
operator ()	stl_function.h	/^  Arg2 operator()(const Arg1&, const Arg2& y) const { return y; }$/;"	f	struct:project2nd
operator ()	stl_function.h	/^  Result operator()(Arg x) const { return ptr(x); }$/;"	f	class:pointer_to_unary_function
operator ()	stl_function.h	/^  S operator()(T& r) const { return (r.*f)(); }$/;"	f	class:mem_fun_ref_t
operator ()	stl_function.h	/^  S operator()(T& r, A x) const { return (r.*f)(x); }$/;"	f	class:mem_fun1_ref_t
operator ()	stl_function.h	/^  S operator()(T* p) const { return (p->*f)(); }$/;"	f	class:mem_fun_t
operator ()	stl_function.h	/^  S operator()(T* p, A x) const { return (p->*f)(x); }$/;"	f	class:mem_fun1_t
operator ()	stl_function.h	/^  S operator()(const T& r) const { return (r.*f)(); }$/;"	f	class:const_mem_fun_ref_t
operator ()	stl_function.h	/^  S operator()(const T& r, A x) const { return (r.*f)(x); }$/;"	f	class:const_mem_fun1_ref_t
operator ()	stl_function.h	/^  S operator()(const T* p) const { return (p->*f)(); }$/;"	f	class:const_mem_fun_t
operator ()	stl_function.h	/^  S operator()(const T* p, A x) const { return (p->*f)(x); }$/;"	f	class:const_mem_fun1_t
operator ()	stl_function.h	/^  bool operator()(const typename Predicate::argument_type& x) const {$/;"	f	class:unary_negate
operator ()	stl_function.h	/^  bool operator()(const typename Predicate::first_argument_type& x, $/;"	f	class:binary_negate
operator ()	stl_function.h	/^  const Result& operator()(const Arg1&, const Arg2&) const {$/;"	f	struct:constant_binary_fun
operator ()	stl_function.h	/^  const Result& operator()(const Argument&) const { return val; }$/;"	f	struct:constant_unary_fun
operator ()	stl_function.h	/^  const T& operator()(const T& x) const { return x; }$/;"	f	struct:identity
operator ()	stl_function.h	/^  const result_type& operator()() const { return val; }$/;"	f	struct:constant_void_fun
operator ()	stl_function.h	/^  const typename Pair::first_type& operator()(const Pair& x) const$/;"	f	struct:select1st
operator ()	stl_function.h	/^  const typename Pair::second_type& operator()(const Pair& x) const$/;"	f	struct:select2nd
operator ()	stl_function.h	/^  operator()(const typename Operation2::argument_type& x) const {$/;"	f	class:binary_compose
operator ()	stl_function.h	/^  operator()(const typename Operation2::argument_type& x) const {$/;"	f	class:unary_compose
operator ()	stl_function.h	/^  operator()(const typename Operation::first_argument_type& x) const {$/;"	f	class:binder2nd
operator ()	stl_function.h	/^  operator()(const typename Operation::second_argument_type& x) const {$/;"	f	class:binder1st
operator ()	stl_function.h	/^  unsigned int operator()(unsigned int limit) {$/;"	f	class:subtractive_rng
operator ()	stl_function.h	/^  void operator()(T& r) const { (r.*f)(); }$/;"	f	class:mem_fun_ref_t
operator ()	stl_function.h	/^  void operator()(T& r, A x) const { (r.*f)(x); }$/;"	f	class:mem_fun1_ref_t
operator ()	stl_function.h	/^  void operator()(T* p) const { (p->*f)(); }$/;"	f	class:mem_fun_t
operator ()	stl_function.h	/^  void operator()(T* p, A x) const { (p->*f)(x); }$/;"	f	class:mem_fun1_t
operator ()	stl_function.h	/^  void operator()(const T& r) const { (r.*f)(); }$/;"	f	class:const_mem_fun_ref_t
operator ()	stl_function.h	/^  void operator()(const T& r, A x) const { (r.*f)(x); }$/;"	f	class:const_mem_fun1_ref_t
operator ()	stl_function.h	/^  void operator()(const T* p) const { (p->*f)(); }$/;"	f	class:const_mem_fun_t
operator ()	stl_function.h	/^  void operator()(const T* p, A x) const { (p->*f)(x); }$/;"	f	class:const_mem_fun1_t
operator ()	stl_hash_fun.h	/^  size_t operator()(char x) const { return x; }$/;"	f	struct:hash
operator ()	stl_hash_fun.h	/^  size_t operator()(const char* s) const { return __stl_hash_string(s); }$/;"	f	struct:hash
operator ()	stl_hash_fun.h	/^  size_t operator()(int x) const { return x; }$/;"	f	struct:hash
operator ()	stl_hash_fun.h	/^  size_t operator()(long x) const { return x; }$/;"	f	struct:hash
operator ()	stl_hash_fun.h	/^  size_t operator()(short x) const { return x; }$/;"	f	struct:hash
operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned char x) const { return x; }$/;"	f	struct:hash
operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned int x) const { return x; }$/;"	f	struct:hash
operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned long x) const { return x; }$/;"	f	struct:hash
operator ()	stl_hash_fun.h	/^  size_t operator()(unsigned short x) const { return x; }$/;"	f	struct:hash
operator ()	stl_map.h	/^    bool operator()(const value_type& x, const value_type& y) const {$/;"	f	class:map::value_compare
operator ()	stl_multimap.h	/^    bool operator()(const value_type& x, const value_type& y) const {$/;"	f	class:multimap::value_compare
operator ()	stl_rope.h	/^		rope operator() (const rope& x, const rope& y) {$/;"	f	struct:rope::concat_fn
operator ()	stl_rope.h	/^    virtual void operator()(size_t start_pos, size_t req_len,$/;"	f	struct:__rope_RopeSubstring
operator ()	stl_rope.h	/^  size_t operator()(const crope& str) const$/;"	f	struct:hash
operator ()	stl_rope.h	/^  size_t operator()(const wrope& str) const$/;"	f	struct:hash
operator *	stl_bvector.h	/^  const_reference operator*() const {$/;"	f	struct:__bit_const_iterator
operator *	stl_bvector.h	/^  reference operator*() const { return reference(p, 1U << offset); }$/;"	f	struct:__bit_iterator
operator *	stl_deque.h	/^  reference operator*() const { return *cur; }$/;"	f	struct:__deque_iterator::__deque_iterator
operator *	stl_hashtable.h	/^  reference operator*() const { return cur->val; }$/;"	f	struct:__hashtable_const_iterator
operator *	stl_hashtable.h	/^  reference operator*() const { return cur->val; }$/;"	f	struct:__hashtable_iterator
operator *	stl_iterator.h	/^  Reference operator*() const { return *(current - 1); }$/;"	f	class:reverse_iterator
operator *	stl_iterator.h	/^  Reference operator*() const {$/;"	f	class:reverse_bidirectional_iterator
operator *	stl_iterator.h	/^  back_insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:back_insert_iterator
operator *	stl_iterator.h	/^  front_insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:front_insert_iterator
operator *	stl_iterator.h	/^  insert_iterator<Container>& operator*() { return *this; }$/;"	f	class:insert_iterator
operator *	stl_iterator.h	/^  ostream_iterator<T>& operator*() { return *this; }$/;"	f	class:ostream_iterator
operator *	stl_iterator.h	/^  reference operator*() const { return value; }$/;"	f	class:istream_iterator
operator *	stl_iterator.h	/^  reference operator*() const {$/;"	f	class:reverse_iterator
operator *	stl_list.h	/^  reference operator*() const { return (*node).data; }$/;"	f	struct:__list_iterator
operator *	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator*() { return *this; }$/;"	f	class:raw_storage_iterator
operator *	stl_rope.h	/^	sequence_buffer& operator*() { return *this; }$/;"	f	class:sequence_buffer
operator *	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> & operator*() { return *ptr; }$/;"	f	struct:__rope_self_destruct_ptr
operator *	stl_rope.h	/^    __rope_charT_ref_proxy<charT,Alloc> operator *() const {$/;"	f	class:__rope_charT_ptr_proxy
operator *	stl_rope.h	/^    reference operator*() {$/;"	f	class:__rope_const_iterator
operator *	stl_rope.h	/^    reference operator*() {$/;"	f	class:__rope_iterator
operator *	stl_slist.h	/^  reference operator*() const { return ((list_node*) node)->data; }$/;"	f	struct:__slist_iterator
operator *	stl_tree.h	/^  reference operator*() const { return link_type(node)->value_field; }$/;"	f	struct:__rb_tree_iterator
operator +	stl_bvector.h	/^  const_iterator operator+(difference_type i) const {$/;"	f	struct:__bit_const_iterator
operator +	stl_bvector.h	/^  iterator operator+(difference_type i) const {$/;"	f	struct:__bit_iterator
operator +	stl_deque.h	/^  self operator+(difference_type n) const {$/;"	f	struct:__deque_iterator::__deque_iterator
operator +	stl_iterator.h	/^  self operator+(Distance n) const {$/;"	f	class:reverse_iterator
operator +	stl_iterator.h	/^  self operator+(difference_type n) const {$/;"	f	class:reverse_iterator
operator +	stl_iterator.h	/^operator+(Dist n, const reverse_iterator<RandomAccessIter, T, Ref, Dist>& x) {$/;"	f
operator +	stl_iterator.h	/^operator+(reverse_iterator<Iterator>::difference_type n,$/;"	f
operator +	stl_rope.h	/^operator+ (const rope<charT,Alloc> &left, charT right) {$/;"	f
operator +	stl_rope.h	/^operator+ (const rope<charT,Alloc> &left,$/;"	f
operator +	stl_rope.h	/^operator+(const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator +	stl_rope.h	/^operator+(const __rope_iterator<charT,Alloc> & x,$/;"	f
operator +	stl_rope.h	/^operator+(ptrdiff_t n,$/;"	f
operator ++	stl_bvector.h	/^  const_iterator operator++(int) {$/;"	f	struct:__bit_const_iterator
operator ++	stl_bvector.h	/^  const_iterator& operator++() {$/;"	f	struct:__bit_const_iterator
operator ++	stl_bvector.h	/^  iterator operator++(int) {$/;"	f	struct:__bit_iterator
operator ++	stl_bvector.h	/^  iterator& operator++() {$/;"	f	struct:__bit_iterator
operator ++	stl_deque.h	/^  self operator++(int)  {$/;"	f	struct:__deque_iterator::__deque_iterator
operator ++	stl_deque.h	/^  self& operator++() {$/;"	f	struct:__deque_iterator::__deque_iterator
operator ++	stl_hashtable.h	/^__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++()$/;"	f	class:__hashtable_const_iterator
operator ++	stl_hashtable.h	/^__hashtable_const_iterator<V, K, HF, ExK, EqK, A>::operator++(int)$/;"	f	class:__hashtable_const_iterator
operator ++	stl_hashtable.h	/^__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++()$/;"	f	class:__hashtable_iterator
operator ++	stl_hashtable.h	/^__hashtable_iterator<V, K, HF, ExK, EqK, A>::operator++(int)$/;"	f	class:__hashtable_iterator
operator ++	stl_iterator.h	/^  back_insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:back_insert_iterator
operator ++	stl_iterator.h	/^  back_insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:back_insert_iterator
operator ++	stl_iterator.h	/^  front_insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:front_insert_iterator
operator ++	stl_iterator.h	/^  front_insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:front_insert_iterator
operator ++	stl_iterator.h	/^  insert_iterator<Container>& operator++() { return *this; }$/;"	f	class:insert_iterator
operator ++	stl_iterator.h	/^  insert_iterator<Container>& operator++(int) { return *this; }$/;"	f	class:insert_iterator
operator ++	stl_iterator.h	/^  istream_iterator<T, Distance> operator++(int)  {$/;"	f	class:istream_iterator
operator ++	stl_iterator.h	/^  istream_iterator<T, Distance>& operator++() { $/;"	f	class:istream_iterator
operator ++	stl_iterator.h	/^  ostream_iterator<T>& operator++() { return *this; } $/;"	f	class:ostream_iterator
operator ++	stl_iterator.h	/^  ostream_iterator<T>& operator++(int) { return *this; } $/;"	f	class:ostream_iterator
operator ++	stl_iterator.h	/^  self operator++(int) {$/;"	f	class:reverse_bidirectional_iterator
operator ++	stl_iterator.h	/^  self operator++(int) {$/;"	f	class:reverse_iterator
operator ++	stl_iterator.h	/^  self& operator++() {$/;"	f	class:reverse_bidirectional_iterator
operator ++	stl_iterator.h	/^  self& operator++() {$/;"	f	class:reverse_iterator
operator ++	stl_list.h	/^  self operator++(int) { $/;"	f	struct:__list_iterator
operator ++	stl_list.h	/^  self& operator++() { $/;"	f	struct:__list_iterator
operator ++	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T> operator++(int) {$/;"	f	class:raw_storage_iterator
operator ++	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator++() {$/;"	f	class:raw_storage_iterator
operator ++	stl_rope.h	/^	sequence_buffer& operator++() { return *this; }$/;"	f	class:sequence_buffer
operator ++	stl_rope.h	/^	sequence_buffer& operator++(int) { return *this; }$/;"	f	class:sequence_buffer
operator ++	stl_rope.h	/^    __rope_const_iterator operator++(int) {$/;"	f	class:__rope_const_iterator
operator ++	stl_rope.h	/^    __rope_const_iterator& operator++() {$/;"	f	class:__rope_const_iterator
operator ++	stl_rope.h	/^    __rope_iterator operator++(int) {$/;"	f	class:__rope_iterator
operator ++	stl_rope.h	/^    __rope_iterator& operator++() {$/;"	f	class:__rope_iterator
operator ++	stl_slist.h	/^  self operator++(int)$/;"	f	struct:__slist_iterator
operator ++	stl_slist.h	/^  self& operator++()$/;"	f	struct:__slist_iterator
operator ++	stl_tree.h	/^  self operator++(int) {$/;"	f	struct:__rb_tree_iterator
operator ++	stl_tree.h	/^  self& operator++() { increment(); return *this; }$/;"	f	struct:__rb_tree_iterator
operator +=	stl_bvector.h	/^  const_iterator& operator+=(difference_type i) {$/;"	f	struct:__bit_const_iterator
operator +=	stl_bvector.h	/^  iterator& operator+=(difference_type i) {$/;"	f	struct:__bit_iterator
operator +=	stl_deque.h	/^  self& operator+=(difference_type n) {$/;"	f	struct:__deque_iterator::__deque_iterator
operator +=	stl_iterator.h	/^  self& operator+=(Distance n) {$/;"	f	class:reverse_iterator
operator +=	stl_iterator.h	/^  self& operator+=(difference_type n) {$/;"	f	class:reverse_iterator
operator +=	stl_rope.h	/^    __rope_const_iterator& operator+=(ptrdiff_t n) {$/;"	f	class:__rope_const_iterator
operator +=	stl_rope.h	/^    __rope_iterator& operator+=(difference_type n) {$/;"	f	class:__rope_iterator
operator +=	stl_rope.h	/^operator+= (rope<charT,Alloc> &left, charT right) {$/;"	f
operator +=	stl_rope.h	/^operator+= (rope<charT,Alloc> &left,$/;"	f
operator -	stl_bvector.h	/^  const_iterator operator-(difference_type i) const {$/;"	f	struct:__bit_const_iterator
operator -	stl_bvector.h	/^  difference_type operator-(const_iterator x) const {$/;"	f	struct:__bit_const_iterator
operator -	stl_bvector.h	/^  difference_type operator-(iterator x) const {$/;"	f	struct:__bit_iterator
operator -	stl_bvector.h	/^  iterator operator-(difference_type i) const {$/;"	f	struct:__bit_iterator
operator -	stl_deque.h	/^  difference_type operator-(const self& x) const {$/;"	f	struct:__deque_iterator::__deque_iterator
operator -	stl_deque.h	/^  self operator-(difference_type n) const {$/;"	f	struct:__deque_iterator::__deque_iterator
operator -	stl_iterator.h	/^  self operator-(Distance n) const {$/;"	f	class:reverse_iterator
operator -	stl_iterator.h	/^  self operator-(difference_type n) const {$/;"	f	class:reverse_iterator
operator -	stl_iterator.h	/^inline Distance operator-(const reverse_iterator<RandomAccessIterator, T,$/;"	f
operator -	stl_iterator.h	/^operator-(const reverse_iterator<Iterator>& x, $/;"	f
operator -	stl_rope.h	/^inline ptrdiff_t operator-(const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator -	stl_rope.h	/^inline ptrdiff_t operator-(const __rope_iterator<charT,Alloc> & x,$/;"	f
operator -	stl_rope.h	/^operator-(const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator -	stl_rope.h	/^operator-(const __rope_iterator<charT,Alloc> & x,$/;"	f
operator --	stl_bvector.h	/^  const_iterator operator--(int) {$/;"	f	struct:__bit_const_iterator
operator --	stl_bvector.h	/^  const_iterator& operator--() {$/;"	f	struct:__bit_const_iterator
operator --	stl_bvector.h	/^  iterator operator--(int) {$/;"	f	struct:__bit_iterator
operator --	stl_bvector.h	/^  iterator& operator--() {$/;"	f	struct:__bit_iterator
operator --	stl_deque.h	/^  self operator--(int) {$/;"	f	struct:__deque_iterator::__deque_iterator
operator --	stl_deque.h	/^  self& operator--() {$/;"	f	struct:__deque_iterator::__deque_iterator
operator --	stl_iterator.h	/^  self operator--(int) {$/;"	f	class:reverse_bidirectional_iterator
operator --	stl_iterator.h	/^  self operator--(int) {$/;"	f	class:reverse_iterator
operator --	stl_iterator.h	/^  self& operator--() {$/;"	f	class:reverse_bidirectional_iterator
operator --	stl_iterator.h	/^  self& operator--() {$/;"	f	class:reverse_iterator
operator --	stl_list.h	/^  self operator--(int) { $/;"	f	struct:__list_iterator
operator --	stl_list.h	/^  self& operator--() { $/;"	f	struct:__list_iterator
operator --	stl_rope.h	/^    __rope_const_iterator operator--(int) {$/;"	f	class:__rope_const_iterator
operator --	stl_rope.h	/^    __rope_const_iterator& operator--() {$/;"	f	class:__rope_const_iterator
operator --	stl_rope.h	/^    __rope_iterator operator--(int) {$/;"	f	class:__rope_iterator
operator --	stl_rope.h	/^    __rope_iterator& operator--() {$/;"	f	class:__rope_iterator
operator --	stl_tree.h	/^  self operator--(int) {$/;"	f	struct:__rb_tree_iterator
operator --	stl_tree.h	/^  self& operator--() { decrement(); return *this; }$/;"	f	struct:__rb_tree_iterator
operator -=	stl_bvector.h	/^  const_iterator& operator-=(difference_type i) {$/;"	f	struct:__bit_const_iterator
operator -=	stl_bvector.h	/^  iterator& operator-=(difference_type i) {$/;"	f	struct:__bit_iterator
operator -=	stl_deque.h	/^  self& operator-=(difference_type n) { return *this += -n; }$/;"	f	struct:__deque_iterator::__deque_iterator
operator -=	stl_iterator.h	/^  self& operator-=(Distance n) {$/;"	f	class:reverse_iterator
operator -=	stl_iterator.h	/^  self& operator-=(difference_type n) {$/;"	f	class:reverse_iterator
operator -=	stl_rope.h	/^    __rope_const_iterator& operator-=(ptrdiff_t n) {$/;"	f	class:__rope_const_iterator
operator -=	stl_rope.h	/^    __rope_iterator& operator-=(difference_type n) {$/;"	f	class:__rope_iterator
operator ->	stl_deque.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__deque_iterator::__deque_iterator
operator ->	stl_hashtable.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__hashtable_const_iterator
operator ->	stl_hashtable.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__hashtable_iterator
operator ->	stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:istream_iterator
operator ->	stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:reverse_bidirectional_iterator
operator ->	stl_iterator.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	class:reverse_iterator
operator ->	stl_list.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__list_iterator
operator ->	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * operator->() { return ptr; }$/;"	f	struct:__rope_self_destruct_ptr
operator ->	stl_slist.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__slist_iterator
operator ->	stl_tree.h	/^  pointer operator->() const { return &(operator*()); }$/;"	f	struct:__rb_tree_iterator
operator <	stl_bvector.h	/^  bool operator<(const __bit_reference& x) const {$/;"	f	struct:__bit_reference
operator <	stl_bvector.h	/^  bool operator<(const_iterator x) const {$/;"	f	struct:__bit_const_iterator
operator <	stl_bvector.h	/^  bool operator<(iterator x) const {$/;"	f	struct:__bit_iterator
operator <	stl_bvector.h	/^inline bool operator<(const bit_vector& x, const bit_vector& y) {$/;"	f
operator <	stl_deque.h	/^  bool operator<(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque
operator <	stl_deque.h	/^  bool operator<(const self& x) const {$/;"	f	struct:__deque_iterator::__deque_iterator
operator <	stl_deque.h	/^bool operator<(const deque<T, Alloc, BufSiz>& x,$/;"	f	struct:__deque_iterator
operator <	stl_iterator.h	/^inline bool operator<(const reverse_iterator<Iterator>& x, $/;"	f
operator <	stl_iterator.h	/^inline bool operator<(const reverse_iterator<RandomAccessIterator, T,$/;"	f
operator <	stl_list.h	/^inline bool operator<(const list<T, Alloc>& x, const list<T, Alloc>& y) {$/;"	f
operator <	stl_map.h	/^inline bool operator<(const map<Key, T, Compare, Alloc>& x, $/;"	f
operator <	stl_multimap.h	/^inline bool operator<(const multimap<Key, T, Compare, Alloc>& x, $/;"	f
operator <	stl_multiset.h	/^inline bool operator<(const multiset<Key, Compare, Alloc>& x, $/;"	f
operator <	stl_pair.h	/^inline bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y) { $/;"	f
operator <	stl_queue.h	/^bool operator<(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {$/;"	f
operator <	stl_rope.h	/^inline bool operator< (const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator <	stl_rope.h	/^inline bool operator< (const __rope_iterator<charT,Alloc> & x,$/;"	f
operator <	stl_rope.h	/^operator< (const rope<charT,Alloc> &left, const rope<charT,Alloc> &right) {$/;"	f
operator <	stl_set.h	/^inline bool operator<(const set<Key, Compare, Alloc>& x, $/;"	f
operator <	stl_slist.h	/^inline bool operator<(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)$/;"	f
operator <	stl_stack.h	/^bool operator<(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {$/;"	f
operator <	stl_tree.h	/^inline bool operator<(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f
operator <	stl_vector.h	/^inline bool operator<(const vector<T, Alloc>& x, const vector<T, Alloc>& y) {$/;"	f
operator <<	ropeimpl.h	/^ostream& operator<< (ostream& o, const rope<charT, Alloc>& r)$/;"	f
operator <=	stl_relops.h	/^inline bool operator<=(const T& x, const T& y) {$/;"	f
operator =	ropeimpl.h	/^__rope_charT_ref_proxy<charT, Alloc>::operator= (charT c) {$/;"	f	class:__rope_charT_ref_proxy
operator =	stl_bvector.h	/^  __BVECTOR& operator=(const __BVECTOR& x) {$/;"	f	class:vector
operator =	stl_bvector.h	/^  __bit_reference& operator=(bool x) {$/;"	f	struct:__bit_reference
operator =	stl_bvector.h	/^  __bit_reference& operator=(const __bit_reference& x) { return *this = bool(x); }$/;"	f	struct:__bit_reference
operator =	stl_deque.h	/^  deque& operator= (const deque& x) {$/;"	f	class:__deque_iterator::deque
operator =	stl_hashtable.h	/^  hashtable& operator= (const hashtable& ht)$/;"	f	class:hashtable
operator =	stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:back_insert_iterator
operator =	stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:front_insert_iterator
operator =	stl_iterator.h	/^  operator=(const typename Container::value_type& value) { $/;"	f	class:insert_iterator
operator =	stl_iterator.h	/^  ostream_iterator<T>& operator=(const T& value) { $/;"	f	class:ostream_iterator
operator =	stl_list.h	/^list<T, Alloc>& list<T, Alloc>::operator=(const list<T, Alloc>& x) {$/;"	f	class:list
operator =	stl_map.h	/^  map<Key, T, Compare, Alloc>& operator=(const map<Key, T, Compare, Alloc>& x)$/;"	f	class:map
operator =	stl_multimap.h	/^  operator=(const multimap<Key, T, Compare, Alloc>& x) {$/;"	f	class:multimap
operator =	stl_multiset.h	/^  operator=(const multiset<Key, Compare, Alloc>& x) {$/;"	f	class:multiset
operator =	stl_raw_storage_iter.h	/^  raw_storage_iterator<ForwardIterator, T>& operator=(const T& element) {$/;"	f	class:raw_storage_iterator
operator =	stl_rope.h	/^	rope& operator=(const rope& x)$/;"	f	class:rope
operator =	stl_rope.h	/^	sequence_buffer& operator= (const sequence_buffer& x) {$/;"	f	class:sequence_buffer
operator =	stl_rope.h	/^	sequence_buffer& operator= (sequence_buffer& x) {$/;"	f	class:sequence_buffer
operator =	stl_rope.h	/^	sequence_buffer& operator=(const value_type& rhs)$/;"	f	class:sequence_buffer
operator =	stl_rope.h	/^    __rope_charT_ptr_proxy& operator= (const __rope_charT_ptr_proxy& x) {$/;"	f	class:__rope_charT_ptr_proxy
operator =	stl_rope.h	/^    __rope_charT_ref_proxy& operator= (const __rope_charT_ref_proxy& c) {$/;"	f	class:__rope_charT_ref_proxy
operator =	stl_rope.h	/^    __rope_const_iterator& operator= (const __rope_const_iterator & x) {$/;"	f	class:__rope_const_iterator
operator =	stl_rope.h	/^    __rope_iterator& operator= (const __rope_iterator & x) {$/;"	f	class:__rope_iterator
operator =	stl_rope.h	/^    __rope_self_destruct_ptr & operator= (__rope_RopeBase<charT,Alloc> * x)$/;"	f	struct:__rope_self_destruct_ptr
operator =	stl_set.h	/^  set<Key, Compare, Alloc>& operator=(const set<Key, Compare, Alloc>& x) { $/;"	f	class:set
operator =	stl_slist.h	/^slist<T, Alloc>& slist<T,Alloc>::operator=(const slist<T, Alloc>& L)$/;"	f	class:slist
operator =	stl_tempbuf.h	/^  void operator=(const temporary_buffer&) {}$/;"	f	class:temporary_buffer
operator =	stl_tree.h	/^operator=(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) {$/;"	f	class:rb_tree
operator =	stl_vector.h	/^vector<T, Alloc>& vector<T, Alloc>::operator=(const vector<T, Alloc>& x) {$/;"	f	class:vector
operator ==	stl_bvector.h	/^  bool operator==(const __bit_reference& x) const {$/;"	f	struct:__bit_reference
operator ==	stl_bvector.h	/^  bool operator==(const const_iterator& x) const {$/;"	f	struct:__bit_const_iterator
operator ==	stl_bvector.h	/^  bool operator==(const iterator& x) const {$/;"	f	struct:__bit_iterator
operator ==	stl_bvector.h	/^inline bool operator==(const bit_vector& x, const bit_vector& y) {$/;"	f
operator ==	stl_deque.h	/^  bool operator==(const deque<T, Alloc, 0>& x) const {$/;"	f	class:__deque_iterator::deque
operator ==	stl_deque.h	/^  bool operator==(const self& x) const { return cur == x.cur; }$/;"	f	struct:__deque_iterator::__deque_iterator
operator ==	stl_deque.h	/^bool operator==(const deque<T, Alloc, BufSiz>& x,$/;"	f	struct:__deque_iterator
operator ==	stl_hash_map.h	/^inline bool operator==(const hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f
operator ==	stl_hash_map.h	/^inline bool operator==(const hash_multimap<Key, T, HF, EqKey, Alloc>& hm1,$/;"	f
operator ==	stl_hash_set.h	/^inline bool operator==(const hash_multiset<Val, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
operator ==	stl_hash_set.h	/^inline bool operator==(const hash_set<Value, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
operator ==	stl_hashtable.h	/^  bool operator==(const const_iterator& it) const { return cur == it.cur; }$/;"	f	struct:__hashtable_const_iterator
operator ==	stl_hashtable.h	/^  bool operator==(const iterator& it) const { return cur == it.cur; }$/;"	f	struct:__hashtable_iterator
operator ==	stl_hashtable.h	/^bool operator==(const hashtable<V, K, HF, Ex, Eq, A>& ht1,$/;"	f
operator ==	stl_iterator.h	/^inline bool operator==($/;"	f
operator ==	stl_iterator.h	/^inline bool operator==(const istream_iterator<T, Distance>& x,$/;"	f
operator ==	stl_iterator.h	/^inline bool operator==(const reverse_iterator<Iterator>& x, $/;"	f
operator ==	stl_iterator.h	/^inline bool operator==(const reverse_iterator<RandomAccessIterator, T,$/;"	f
operator ==	stl_list.h	/^  bool operator==(const self& x) const { return node == x.node; }$/;"	f	struct:__list_iterator
operator ==	stl_list.h	/^inline bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y) {$/;"	f
operator ==	stl_map.h	/^inline bool operator==(const map<Key, T, Compare, Alloc>& x, $/;"	f
operator ==	stl_multimap.h	/^inline bool operator==(const multimap<Key, T, Compare, Alloc>& x, $/;"	f
operator ==	stl_multiset.h	/^inline bool operator==(const multiset<Key, Compare, Alloc>& x, $/;"	f
operator ==	stl_pair.h	/^inline bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y) { $/;"	f
operator ==	stl_queue.h	/^bool operator==(const queue<T, Sequence>& x, const queue<T, Sequence>& y) {$/;"	f
operator ==	stl_rope.h	/^inline bool operator== (const __rope_charT_ptr_proxy<charT,Alloc> & x,$/;"	f
operator ==	stl_rope.h	/^inline bool operator== (const __rope_const_iterator<charT,Alloc> & x,$/;"	f
operator ==	stl_rope.h	/^inline bool operator== (const __rope_iterator<charT,Alloc> & x,$/;"	f
operator ==	stl_rope.h	/^operator== (const rope<charT,Alloc> &left, const rope<charT,Alloc> &right) {$/;"	f
operator ==	stl_set.h	/^inline bool operator==(const set<Key, Compare, Alloc>& x, $/;"	f
operator ==	stl_slist.h	/^  bool operator==(const __slist_iterator_base& x) const {$/;"	f	struct:__slist_iterator_base
operator ==	stl_slist.h	/^bool operator==(const slist<T, Alloc>& L1, const slist<T, Alloc>& L2)$/;"	f
operator ==	stl_stack.h	/^bool operator==(const stack<T, Sequence>& x, const stack<T, Sequence>& y) {$/;"	f
operator ==	stl_tree.h	/^inline bool operator==(const __rb_tree_base_iterator& x,$/;"	f
operator ==	stl_tree.h	/^inline bool operator==(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f
operator ==	stl_vector.h	/^inline bool operator==(const vector<T, Alloc>& x, const vector<T, Alloc>& y) {$/;"	f
operator >	stl_relops.h	/^inline bool operator>(const T& x, const T& y) {$/;"	f
operator >=	stl_relops.h	/^inline bool operator>=(const T& x, const T& y) {$/;"	f
operator []	stl_bvector.h	/^  const_reference operator[](difference_type i) { $/;"	f	struct:__bit_const_iterator
operator []	stl_bvector.h	/^  const_reference operator[](size_type n) const {$/;"	f	class:vector
operator []	stl_bvector.h	/^  reference operator[](difference_type i) { return *(*this + i); }$/;"	f	struct:__bit_iterator
operator []	stl_bvector.h	/^  reference operator[](size_type n) {$/;"	f	class:vector
operator []	stl_deque.h	/^  const_reference operator[](size_type n) const {$/;"	f	class:__deque_iterator::deque
operator []	stl_deque.h	/^  reference operator[](difference_type n) const { return *(*this + n); }$/;"	f	struct:__deque_iterator::__deque_iterator
operator []	stl_deque.h	/^  reference operator[](size_type n) { return start[difference_type(n)]; }$/;"	f	class:__deque_iterator::deque
operator []	stl_hash_map.h	/^  T& operator[](const key_type& key) {$/;"	f	class:hash_map
operator []	stl_iterator.h	/^  Reference operator[](Distance n) const { return *(*this + n); }$/;"	f	class:reverse_iterator
operator []	stl_iterator.h	/^  reference operator[](difference_type n) const { return *(*this + n); }  $/;"	f	class:reverse_iterator
operator []	stl_map.h	/^  T& operator[](const key_type& k) {$/;"	f	class:map
operator []	stl_rope.h	/^	    reference operator[] (size_type pos) {$/;"	f	class:rope
operator []	stl_rope.h	/^	charT operator[] (size_type pos) const {$/;"	f	class:rope
operator []	stl_rope.h	/^    reference operator[](ptrdiff_t n) {$/;"	f	class:__rope_iterator
operator []	stl_rope.h	/^    reference operator[](size_t n) {$/;"	f	class:__rope_const_iterator
operator []	stl_vector.h	/^  const_reference operator[](size_type n) const { return *(begin() + n); }$/;"	f	class:vector
operator []	stl_vector.h	/^  reference operator[](size_type n) { return *(begin() + n); }$/;"	f	class:vector
operator __rope_RopeBase<charT,Alloc> *	stl_rope.h	/^    operator __rope_RopeBase<charT,Alloc> *() { return ptr; }$/;"	f	struct:__rope_self_destruct_ptr
operator bool	stl_bvector.h	/^  operator bool() const { return !(!(*p & mask)); }$/;"	f	struct:__bit_reference
operator charT	ropeimpl.h	/^inline __rope_charT_ref_proxy<charT, Alloc>::operator charT () const$/;"	f	class:__rope_charT_ref_proxy
original_len	stl_tempbuf.h	/^  ptrdiff_t original_len;$/;"	m	class:temporary_buffer
ostream_iterator	stl_iterator.h	/^  ostream_iterator(ostream& s) : stream(&s), string(0) {}$/;"	f	class:ostream_iterator
ostream_iterator	stl_iterator.h	/^  ostream_iterator(ostream& s, const char* c) : stream(&s), string(c)  {}$/;"	f	class:ostream_iterator
ostream_iterator	stl_iterator.h	/^class ostream_iterator {$/;"	c
output_iterator	stl_iterator.h	/^struct output_iterator {$/;"	s
output_iterator_tag	stl_iterator.h	/^struct output_iterator_tag {};$/;"	s
p	stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_const_iterator
p	stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_iterator
p	stl_bvector.h	/^  unsigned int* p;$/;"	m	struct:__bit_reference
pair	stl_pair.h	/^  pair() : first(T1()), second(T2()) {}$/;"	f	struct:pair
pair	stl_pair.h	/^  pair(const T1& a, const T2& b) : first(a), second(b) {}$/;"	f	struct:pair
pair	stl_pair.h	/^  pair(const pair<U1, U2>& p) : first(p.first), second(p.second) {}$/;"	f	struct:pair
pair	stl_pair.h	/^struct pair {$/;"	s
pair_iterator_bool	stl_set.h	/^  typedef  pair<iterator, bool> pair_iterator_bool; $/;"	t	class:set
parent	stl_tree.h	/^  base_ptr parent;$/;"	m	struct:__rb_tree_node_base
parent	stl_tree.h	/^  static link_type& parent(base_ptr x) { return (link_type&)(x->parent); }$/;"	f	class:rb_tree
parent	stl_tree.h	/^  static link_type& parent(link_type x) { return (link_type&)(x->parent); }$/;"	f	class:rb_tree
partial_sort	stl_algo.h	/^inline void partial_sort(RandomAccessIterator first,$/;"	f
partial_sort_copy	stl_algo.h	/^partial_sort_copy(InputIterator first, InputIterator last,$/;"	f
partial_sum	stl_numeric.h	/^OutputIterator partial_sum(InputIterator first, InputIterator last,$/;"	f
partition	stl_algo.h	/^BidirectionalIterator partition(BidirectionalIterator first,$/;"	f
path_cache_len	stl_rope.h	/^    enum { path_cache_len = 4 }; \/\/ Must be <= 9.$/;"	e	enum:__rope_iterator_base::__anon4
path_directions	stl_rope.h	/^    unsigned char path_directions;$/;"	m	class:__rope_iterator_base
path_end	stl_rope.h	/^    const RopeBase * path_end[path_cache_len];$/;"	m	class:__rope_iterator_base
pattern	ropeimpl.h	/^	charT pattern;$/;"	m	class:__rope_find_char_char_consumer
plus	stl_function.h	/^struct plus : public binary_function<T, T, T> {$/;"	s
pointer	defalloc.h	/^    typedef T* pointer;$/;"	t	class:allocator
pointer	defalloc.h	/^    typedef void* pointer;$/;"	t	class:allocator
pointer	stl_bvector.h	/^  typedef __bit_reference* pointer;$/;"	t	class:vector
pointer	stl_bvector.h	/^  typedef __bit_reference* pointer;$/;"	t	struct:__bit_iterator
pointer	stl_bvector.h	/^  typedef const bool*          pointer;$/;"	t	struct:__bit_const_iterator
pointer	stl_deque.h	/^  typedef Ptr pointer;$/;"	t	struct:__deque_iterator::__deque_iterator
pointer	stl_deque.h	/^  typedef value_type* pointer;$/;"	t	class:__deque_iterator::deque
pointer	stl_hash_map.h	/^  typedef typename ht::pointer pointer;$/;"	t	class:hash_map
pointer	stl_hash_map.h	/^  typedef typename ht::pointer pointer;$/;"	t	class:hash_multimap
pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer pointer;$/;"	t	class:hash_multiset
pointer	stl_hash_set.h	/^  typedef typename ht::const_pointer pointer;$/;"	t	class:hash_set
pointer	stl_hashtable.h	/^  typedef Value* pointer;$/;"	t	struct:__hashtable_iterator
pointer	stl_hashtable.h	/^  typedef const Value* pointer;$/;"	t	struct:__hashtable_const_iterator
pointer	stl_hashtable.h	/^  typedef value_type*       pointer;$/;"	t	class:hashtable
pointer	stl_iterator.h	/^          pointer;$/;"	t	class:reverse_iterator
pointer	stl_iterator.h	/^  typedef Pointer   pointer;$/;"	t	struct:iterator
pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	class:reverse_bidirectional_iterator
pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	class:reverse_iterator
pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:bidirectional_iterator
pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:iterator_traits
pointer	stl_iterator.h	/^  typedef T*                         pointer;$/;"	t	struct:random_access_iterator
pointer	stl_iterator.h	/^  typedef T*                   pointer;$/;"	t	struct:forward_iterator
pointer	stl_iterator.h	/^  typedef T*                 pointer;$/;"	t	struct:input_iterator
pointer	stl_iterator.h	/^  typedef const T*                   pointer;$/;"	t	struct:iterator_traits
pointer	stl_iterator.h	/^  typedef const T*           pointer;$/;"	t	class:istream_iterator
pointer	stl_iterator.h	/^  typedef typename Iterator::pointer           pointer;$/;"	t	struct:iterator_traits
pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:back_insert_iterator
pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:front_insert_iterator
pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:insert_iterator
pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	class:ostream_iterator
pointer	stl_iterator.h	/^  typedef void                pointer;$/;"	t	struct:output_iterator
pointer	stl_list.h	/^  typedef Ptr pointer;$/;"	t	struct:__list_iterator
pointer	stl_list.h	/^  typedef value_type* pointer;$/;"	t	class:list
pointer	stl_map.h	/^  typedef typename rep_type::pointer pointer;$/;"	t	class:map
pointer	stl_multimap.h	/^  typedef typename rep_type::pointer pointer;$/;"	t	class:multimap
pointer	stl_multiset.h	/^  typedef typename rep_type::const_pointer pointer;$/;"	t	class:multiset
pointer	stl_raw_storage_iter.h	/^  typedef void                pointer;$/;"	t	class:raw_storage_iterator
pointer	stl_rope.h	/^	typedef __rope_charT_ptr_proxy<charT,Alloc> pointer;$/;"	t	class:rope
pointer	stl_rope.h	/^    typedef __rope_charT_ref_proxy<charT,Alloc>* pointer;$/;"	t	class:__rope_iterator
pointer	stl_rope.h	/^    typedef const charT* pointer;$/;"	t	class:__rope_const_iterator
pointer	stl_set.h	/^  typedef typename rep_type::const_pointer pointer;$/;"	t	class:set
pointer	stl_slist.h	/^  typedef Ptr pointer;$/;"	t	struct:__slist_iterator
pointer	stl_slist.h	/^  typedef value_type* pointer;$/;"	t	class:slist
pointer	stl_tree.h	/^  typedef Ptr pointer;$/;"	t	struct:__rb_tree_iterator
pointer	stl_tree.h	/^  typedef value_type* pointer;$/;"	t	class:rb_tree
pointer	stl_vector.h	/^  typedef value_type* pointer;$/;"	t	class:vector
pointer_to_binary_function	stl_function.h	/^    explicit pointer_to_binary_function(Result (*x)(Arg1, Arg2)) : ptr(x) {}$/;"	f	class:pointer_to_binary_function
pointer_to_binary_function	stl_function.h	/^    pointer_to_binary_function() {}$/;"	f	class:pointer_to_binary_function
pointer_to_binary_function	stl_function.h	/^class pointer_to_binary_function : public binary_function<Arg1, Arg2, Result> {$/;"	c
pointer_to_unary_function	stl_function.h	/^  explicit pointer_to_unary_function(Result (*x)(Arg)) : ptr(x) {}$/;"	f	class:pointer_to_unary_function
pointer_to_unary_function	stl_function.h	/^  pointer_to_unary_function() {}$/;"	f	class:pointer_to_unary_function
pointer_to_unary_function	stl_function.h	/^class pointer_to_unary_function : public unary_function<Arg, Result> {$/;"	c
pop	stl_queue.h	/^  void pop() { c.pop_front(); }$/;"	f	class:queue
pop	stl_queue.h	/^  void pop() {$/;"	f	class:priority_queue
pop	stl_stack.h	/^  void pop() { c.pop_back(); }$/;"	f	class:stack
pop_back	stl_bvector.h	/^  void pop_back() { --finish; }$/;"	f	class:vector
pop_back	stl_deque.h	/^  void pop_back() {$/;"	f	class:__deque_iterator::deque
pop_back	stl_list.h	/^  void pop_back() { $/;"	f	class:list
pop_back	stl_rope.h	/^	void pop_back()$/;"	f	class:rope
pop_back	stl_vector.h	/^  void pop_back() {$/;"	f	class:vector
pop_back_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>:: pop_back_aux() {$/;"	f	class:__deque_iterator::deque
pop_front	stl_deque.h	/^  void pop_front() {$/;"	f	class:__deque_iterator::deque
pop_front	stl_list.h	/^  void pop_front() { erase(begin()); }$/;"	f	class:list
pop_front	stl_rope.h	/^	void pop_front()$/;"	f	class:rope
pop_front	stl_slist.h	/^  void pop_front() {$/;"	f	class:slist
pop_front_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::pop_front_aux() {$/;"	f	class:__deque_iterator::deque
pop_heap	stl_heap.h	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
pop_heap	stl_heap.h	/^inline void pop_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
pos	stl_rope.h	/^    size_t pos;$/;"	m	class:__rope_charT_ptr_proxy
pos	stl_rope.h	/^    size_t pos;$/;"	m	class:__rope_charT_ref_proxy
power	stl_numeric.h	/^T power(T x, Integer n, MonoidOperation op) {$/;"	f
power	stl_numeric.h	/^inline T power(T x, Integer n) {$/;"	f
pred	stl_function.h	/^  Predicate pred;$/;"	m	class:binary_negate
pred	stl_function.h	/^  Predicate pred;$/;"	m	class:unary_negate
prefix	stl_rope.h	/^	sequence *prefix;$/;"	m	class:sequence_buffer
prev	stl_list.h	/^  void_pointer prev;$/;"	m	struct:__list_node
prev_permutation	stl_algo.h	/^bool prev_permutation(BidirectionalIterator first, BidirectionalIterator last,$/;"	f
prev_permutation	stl_algo.h	/^bool prev_permutation(BidirectionalIterator first,$/;"	f
previous	stl_slist.h	/^  const_iterator previous(const_iterator pos) const {$/;"	f	class:slist
previous	stl_slist.h	/^  iterator previous(const_iterator pos) {$/;"	f	class:slist
priority_queue	stl_queue.h	/^  explicit priority_queue(const Compare& x) :  c(), comp(x) {}$/;"	f	class:priority_queue
priority_queue	stl_queue.h	/^  priority_queue() : c() {}$/;"	f	class:priority_queue
priority_queue	stl_queue.h	/^  priority_queue(InputIterator first, InputIterator last) $/;"	f	class:priority_queue
priority_queue	stl_queue.h	/^  priority_queue(InputIterator first, InputIterator last, const Compare& x)$/;"	f	class:priority_queue
priority_queue	stl_queue.h	/^  priority_queue(const value_type* first, const value_type* last) $/;"	f	class:priority_queue
priority_queue	stl_queue.h	/^  priority_queue(const value_type* first, const value_type* last, $/;"	f	class:priority_queue
priority_queue	stl_queue.h	/^class  priority_queue {$/;"	c
project1st	stl_function.h	/^struct project1st : public binary_function<Arg1, Arg2, Arg1> {$/;"	s
project2nd	stl_function.h	/^struct project2nd : public binary_function<Arg1, Arg2, Arg2> {$/;"	s
ptr	stl_function.h	/^    Result (*ptr)(Arg1, Arg2);$/;"	m	class:pointer_to_binary_function
ptr	stl_function.h	/^  Result (*ptr)(Arg);$/;"	m	class:pointer_to_unary_function
ptr	stl_rope.h	/^    __rope_RopeBase<charT,Alloc> * ptr;$/;"	m	struct:__rope_self_destruct_ptr
ptr_fun	stl_function.h	/^inline pointer_to_unary_function<Arg, Result> ptr_fun(Result (*x)(Arg)) {$/;"	f
ptr_fun	stl_function.h	/^ptr_fun(Result (*x)(Arg1, Arg2)) {$/;"	f
push	stl_queue.h	/^  void push(const value_type& x) { c.push_back(x); }$/;"	f	class:queue
push	stl_queue.h	/^  void push(const value_type& x) {$/;"	f	class:priority_queue
push	stl_stack.h	/^  void push(const value_type& x) { c.push_back(x); }$/;"	f	class:stack
push_back	stl_bvector.h	/^  void push_back(bool x) {$/;"	f	class:vector
push_back	stl_deque.h	/^  void push_back(const value_type& t) {$/;"	f	class:__deque_iterator::deque
push_back	stl_list.h	/^  void push_back(const T& x) { insert(end(), x); }$/;"	f	class:list
push_back	stl_rope.h	/^	void push_back(charT x)$/;"	f	class:rope
push_back	stl_rope.h	/^	void push_back(value_type x)$/;"	f	class:sequence_buffer
push_back	stl_vector.h	/^  void push_back(const T& x) {$/;"	f	class:vector
push_back_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::push_back_aux(const value_type& t) {$/;"	f	class:__deque_iterator::deque
push_front	stl_deque.h	/^  void push_front(const value_type& t) {$/;"	f	class:__deque_iterator::deque
push_front	stl_list.h	/^  void push_front(const T& x) { insert(begin(), x); }$/;"	f	class:list
push_front	stl_rope.h	/^	void push_front(charT x)$/;"	f	class:rope
push_front	stl_slist.h	/^  void push_front(const value_type& x)   {$/;"	f	class:slist
push_front_aux	stl_deque.h	/^void deque<T, Alloc, BufSize>::push_front_aux(const value_type& t) {$/;"	f	class:__deque_iterator::deque
push_heap	stl_heap.h	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
push_heap	stl_heap.h	/^inline void push_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
put	stl_rope.h	/^	sequence_buffer& put(value_type x)$/;"	f	class:sequence_buffer
put_node	stl_list.h	/^  void put_node(link_type p) { list_node_allocator::deallocate(p); }$/;"	f	class:list
put_node	stl_tree.h	/^  void put_node(link_type p) { rb_tree_node_allocator::deallocate(p); }$/;"	f	class:rb_tree
queue	stl_queue.h	/^class queue {$/;"	c
random_access_iterator	stl_iterator.h	/^template <class T, class Distance> struct random_access_iterator {$/;"	s
random_access_iterator_tag	stl_iterator.h	/^struct random_access_iterator_tag : public bidirectional_iterator_tag {};$/;"	s
random_sample	stl_algo.h	/^random_sample(InputIterator first, InputIterator last,$/;"	f
random_sample_n	stl_algo.h	/^OutputIterator random_sample_n(ForwardIterator first, ForwardIterator last,$/;"	f
random_shuffle	stl_algo.h	/^inline void random_shuffle(RandomAccessIterator first,$/;"	f
random_shuffle	stl_algo.h	/^void random_shuffle(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
range_initialize	stl_deque.h	/^void deque<T, Alloc, BufSize>::range_initialize(ForwardIterator first,$/;"	f	class:__deque_iterator::deque
range_initialize	stl_deque.h	/^void deque<T, Alloc, BufSize>::range_initialize(InputIterator first,$/;"	f	class:__deque_iterator::deque
range_initialize	stl_list.h	/^  void range_initialize(InputIterator first, InputIterator last) {$/;"	f	class:list
range_initialize	stl_list.h	/^  void range_initialize(const T* first, const T* last) {$/;"	f	class:list
range_initialize	stl_list.h	/^  void range_initialize(const_iterator first, const_iterator last) {$/;"	f	class:list
range_initialize	stl_slist.h	/^  void range_initialize(InputIterator first, InputIterator last) {$/;"	f	class:slist
range_initialize	stl_slist.h	/^  void range_initialize(const value_type* first, const value_type* last) {$/;"	f	class:slist
range_initialize	stl_slist.h	/^  void range_initialize(const_iterator first, const_iterator last) {$/;"	f	class:slist
range_initialize	stl_vector.h	/^  void range_initialize(ForwardIterator first, ForwardIterator last,$/;"	f	class:vector
range_initialize	stl_vector.h	/^  void range_initialize(InputIterator first, InputIterator last,$/;"	f	class:vector
range_insert	stl_vector.h	/^void vector<T, Alloc>::range_insert(iterator pos,$/;"	f	class:vector
range_insert	stl_vector.h	/^void vector<T, Alloc>::range_insert(iterator position,$/;"	f	class:vector
raw_storage_iterator	stl_raw_storage_iter.h	/^  explicit raw_storage_iterator(ForwardIterator x) : iter(x) {}$/;"	f	class:raw_storage_iterator
raw_storage_iterator	stl_raw_storage_iter.h	/^class raw_storage_iterator {$/;"	c
rb_tree	stl_tree.h	/^  rb_tree(const Compare& comp = Compare())$/;"	f	class:rb_tree
rb_tree	stl_tree.h	/^  rb_tree(const rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x) $/;"	f	class:rb_tree
rb_tree	stl_tree.h	/^class rb_tree {$/;"	c
rb_tree_node	stl_tree.h	/^  typedef __rb_tree_node<Value> rb_tree_node;$/;"	t	class:rb_tree
rb_tree_node_allocator	stl_tree.h	/^  typedef simple_alloc<rb_tree_node, Alloc> rb_tree_node_allocator;$/;"	t	class:rb_tree
rbegin	stl_bvector.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:vector
rbegin	stl_bvector.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:vector
rbegin	stl_deque.h	/^  const_reverse_iterator rbegin() const {$/;"	f	class:__deque_iterator::deque
rbegin	stl_deque.h	/^  reverse_iterator rbegin() { return reverse_iterator(finish); }$/;"	f	class:__deque_iterator::deque
rbegin	stl_list.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:list
rbegin	stl_list.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:list
rbegin	stl_map.h	/^  const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:map
rbegin	stl_map.h	/^  reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:map
rbegin	stl_multimap.h	/^  const_reverse_iterator rbegin() const { return t.rbegin(); }$/;"	f	class:multimap
rbegin	stl_multimap.h	/^  reverse_iterator rbegin() { return t.rbegin(); }$/;"	f	class:multimap
rbegin	stl_multiset.h	/^  reverse_iterator rbegin() const { return t.rbegin(); } $/;"	f	class:multiset
rbegin	stl_rope.h	/^	    const_reverse_iterator rbegin() { return const_rbegin(); }$/;"	f	class:rope
rbegin	stl_rope.h	/^	    reverse_iterator rbegin() { return mutable_rbegin(); }$/;"	f	class:rope
rbegin	stl_rope.h	/^	const_reverse_iterator rbegin() const {$/;"	f	class:rope
rbegin	stl_set.h	/^  reverse_iterator rbegin() const { return t.rbegin(); } $/;"	f	class:set
rbegin	stl_tree.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:rb_tree
rbegin	stl_tree.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:rb_tree
rbegin	stl_vector.h	/^  const_reverse_iterator rbegin() const { $/;"	f	class:vector
rbegin	stl_vector.h	/^  reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:vector
read	stl_iterator.h	/^  void read() {$/;"	f	class:istream_iterator
reallocate	stl_alloc.h	/^__default_alloc_template<threads, inst>::reallocate(void *p,$/;"	f	class:__default_alloc_template
reallocate	stl_alloc.h	/^static void * reallocate(void *p, size_t \/* old_sz *\/, size_t new_sz)$/;"	f	class:__malloc_alloc_template
reallocate	stl_alloc.h	/^static void * reallocate(void *p, size_t old_sz, size_t new_sz)$/;"	f	class:debug_alloc
reallocate_map	stl_deque.h	/^void deque<T, Alloc, BufSize>::reallocate_map(size_type nodes_to_add,$/;"	f	class:__deque_iterator::deque
ref	stl_rope.h	/^	  static void ref(RopeBase* t) {}$/;"	f	class:rope
ref	stl_rope.h	/^	  static void ref(RopeBase* t)$/;"	f	class:rope
ref	stl_rope.h	/^	  static void ref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase
ref	stl_rope.h	/^	  static void ref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase
ref_nonnil	stl_rope.h	/^	  void ref_nonnil() {}$/;"	f	struct:__rope_RopeBase
ref_nonnil	stl_rope.h	/^	  void ref_nonnil()$/;"	f	struct:__rope_RopeBase
refcount	stl_rope.h	/^	    long refcount;  	\/\/ InterlockedIncrement wants a long *$/;"	m	struct:__rope_RopeBase
refcount	stl_rope.h	/^	    size_t refcount;$/;"	m	struct:__rope_RopeBase
refcount_lock	stl_rope.h	/^	    pthread_mutex_t refcount_lock;$/;"	m	struct:__rope_RopeBase
reference	defalloc.h	/^    typedef T& reference;$/;"	t	class:allocator
reference	stl_bvector.h	/^  typedef __bit_reference  reference;$/;"	t	struct:__bit_iterator
reference	stl_bvector.h	/^  typedef __bit_reference reference;$/;"	t	class:vector
reference	stl_bvector.h	/^  typedef bool                 reference;$/;"	t	struct:__bit_const_iterator
reference	stl_deque.h	/^  typedef Ref reference;$/;"	t	struct:__deque_iterator::__deque_iterator
reference	stl_deque.h	/^  typedef value_type& reference;$/;"	t	class:__deque_iterator::deque
reference	stl_hash_map.h	/^  typedef typename ht::reference reference;$/;"	t	class:hash_map
reference	stl_hash_map.h	/^  typedef typename ht::reference reference;$/;"	t	class:hash_multimap
reference	stl_hash_set.h	/^  typedef typename ht::const_reference reference;$/;"	t	class:hash_multiset
reference	stl_hash_set.h	/^  typedef typename ht::const_reference reference;$/;"	t	class:hash_set
reference	stl_hashtable.h	/^  typedef Value& reference;$/;"	t	struct:__hashtable_iterator
reference	stl_hashtable.h	/^  typedef const Value& reference;$/;"	t	struct:__hashtable_const_iterator
reference	stl_hashtable.h	/^  typedef value_type&       reference;$/;"	t	class:hashtable
reference	stl_iterator.h	/^          reference;$/;"	t	class:reverse_iterator
reference	stl_iterator.h	/^  typedef Reference                  reference;$/;"	t	class:reverse_bidirectional_iterator
reference	stl_iterator.h	/^  typedef Reference                  reference;$/;"	t	class:reverse_iterator
reference	stl_iterator.h	/^  typedef Reference reference;$/;"	t	struct:iterator
reference	stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:bidirectional_iterator
reference	stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:iterator_traits
reference	stl_iterator.h	/^  typedef T&                         reference;$/;"	t	struct:random_access_iterator
reference	stl_iterator.h	/^  typedef T&                   reference;$/;"	t	struct:forward_iterator
reference	stl_iterator.h	/^  typedef T&                 reference;$/;"	t	struct:input_iterator
reference	stl_iterator.h	/^  typedef const T&                   reference;$/;"	t	struct:iterator_traits
reference	stl_iterator.h	/^  typedef const T&           reference;$/;"	t	class:istream_iterator
reference	stl_iterator.h	/^  typedef typename Iterator::reference         reference;$/;"	t	struct:iterator_traits
reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:back_insert_iterator
reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:front_insert_iterator
reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:insert_iterator
reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	class:ostream_iterator
reference	stl_iterator.h	/^  typedef void                reference;$/;"	t	struct:output_iterator
reference	stl_list.h	/^  typedef Ref reference;$/;"	t	struct:__list_iterator
reference	stl_list.h	/^  typedef value_type& reference;$/;"	t	class:list
reference	stl_map.h	/^  typedef typename rep_type::reference reference;$/;"	t	class:map
reference	stl_multimap.h	/^  typedef typename rep_type::reference reference;$/;"	t	class:multimap
reference	stl_multiset.h	/^  typedef typename rep_type::const_reference reference;$/;"	t	class:multiset
reference	stl_queue.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:priority_queue
reference	stl_queue.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:queue
reference	stl_raw_storage_iter.h	/^  typedef void                reference;$/;"	t	class:raw_storage_iterator
reference	stl_rope.h	/^	typedef __rope_charT_ref_proxy<charT,Alloc> reference;$/;"	t	class:rope
reference	stl_rope.h	/^    typedef __rope_charT_ref_proxy<charT,Alloc>  reference;$/;"	t	class:__rope_iterator
reference	stl_rope.h	/^    typedef charT reference;    \/\/ Really a value.  Returning a reference$/;"	t	class:__rope_const_iterator
reference	stl_set.h	/^  typedef typename rep_type::const_reference reference;$/;"	t	class:set
reference	stl_slist.h	/^  typedef Ref reference;$/;"	t	struct:__slist_iterator
reference	stl_slist.h	/^  typedef value_type& reference;$/;"	t	class:slist
reference	stl_stack.h	/^  typedef typename Sequence::reference reference;$/;"	t	class:stack
reference	stl_tree.h	/^  typedef Ref reference;$/;"	t	struct:__rb_tree_iterator
reference	stl_tree.h	/^  typedef value_type& reference;$/;"	t	class:rb_tree
reference	stl_vector.h	/^  typedef value_type& reference;$/;"	t	class:vector
refill	stl_alloc.h	/^void* __default_alloc_template<threads, inst>::refill(size_t n)$/;"	f	class:__default_alloc_template
remove	stl_algo.h	/^ForwardIterator remove(ForwardIterator first, ForwardIterator last,$/;"	f
remove	stl_list.h	/^void list<T, Alloc>::remove(const T& value) {$/;"	f	class:list
remove	stl_slist.h	/^void slist<T,Alloc>::remove(const T& val)$/;"	f	class:slist
remove_copy	stl_algo.h	/^OutputIterator remove_copy(InputIterator first, InputIterator last,$/;"	f
remove_copy_if	stl_algo.h	/^OutputIterator remove_copy_if(InputIterator first, InputIterator last,$/;"	f
remove_if	stl_algo.h	/^ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,$/;"	f
remove_if	stl_list.h	/^void list<T, Alloc>::remove_if(Predicate pred) {$/;"	f	class:list
remove_if	stl_slist.h	/^template <class Predicate> void slist<T,Alloc>::remove_if(Predicate pred)$/;"	f	class:slist
rend	stl_bvector.h	/^  const_reverse_iterator rend() const { $/;"	f	class:vector
rend	stl_bvector.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:vector
rend	stl_deque.h	/^  const_reverse_iterator rend() const {$/;"	f	class:__deque_iterator::deque
rend	stl_deque.h	/^  reverse_iterator rend() { return reverse_iterator(start); }$/;"	f	class:__deque_iterator::deque
rend	stl_list.h	/^  const_reverse_iterator rend() const { $/;"	f	class:list
rend	stl_list.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:list
rend	stl_map.h	/^  const_reverse_iterator rend() const { return t.rend(); }$/;"	f	class:map
rend	stl_map.h	/^  reverse_iterator rend() { return t.rend(); }$/;"	f	class:map
rend	stl_multimap.h	/^  const_reverse_iterator rend() const { return t.rend(); }$/;"	f	class:multimap
rend	stl_multimap.h	/^  reverse_iterator rend() { return t.rend(); }$/;"	f	class:multimap
rend	stl_multiset.h	/^  reverse_iterator rend() const { return t.rend(); }$/;"	f	class:multiset
rend	stl_rope.h	/^	    const_reverse_iterator rend() { return const_rend(); }$/;"	f	class:rope
rend	stl_rope.h	/^	    reverse_iterator rend() { return mutable_rend(); }$/;"	f	class:rope
rend	stl_rope.h	/^	const_reverse_iterator rend() const {$/;"	f	class:rope
rend	stl_set.h	/^  reverse_iterator rend() const { return t.rend(); }$/;"	f	class:set
rend	stl_tree.h	/^  const_reverse_iterator rend() const { $/;"	f	class:rb_tree
rend	stl_tree.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:rb_tree
rend	stl_vector.h	/^  const_reverse_iterator rend() const { $/;"	f	class:vector
rend	stl_vector.h	/^  reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:vector
rep	stl_hash_map.h	/^  ht rep;$/;"	m	class:hash_map
rep	stl_hash_map.h	/^  ht rep;$/;"	m	class:hash_multimap
rep	stl_hash_set.h	/^  ht rep;$/;"	m	class:hash_multiset
rep	stl_hash_set.h	/^  ht rep;$/;"	m	class:hash_set
rep_type	stl_map.h	/^                  select1st<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:map
rep_type	stl_multimap.h	/^                  select1st<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:multimap
rep_type	stl_multiset.h	/^                  identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:multiset
rep_type	stl_set.h	/^                  identity<value_type>, key_compare, Alloc> rep_type;$/;"	t	class:set
replace	stl_algo.h	/^void replace(ForwardIterator first, ForwardIterator last, const T& old_value,$/;"	f
replace	stl_rope.h	/^	static RopeBase * replace(RopeBase *old, size_t pos1,$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(const iterator& p, charT c)$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(const iterator& p, const charT * c_string)$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(const iterator& p, const charT *i, const charT *j)$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(const iterator& p, const charT *i, size_t n)$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q, charT c)$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(const iterator& p, const iterator& q,$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(const iterator& p, const rope& r)$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(const iterator& p, const_iterator i, const_iterator j)$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(const iterator& p, iterator i, iterator j)$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, charT c) {$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, const charT *c_string) {$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, const charT *i, const charT *j) {$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, const charT *i, size_t i_len) {$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, const const_iterator& i,$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, const iterator& i,$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, const rope& r) {$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, size_t n, charT c) {$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, size_t n, const charT *c_string) {$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, size_t n, const charT *i, const charT *j) {$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, size_t n, const charT *i, size_t i_len) {$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, size_t n, const rope& r) {$/;"	f	class:rope
replace	stl_rope.h	/^	void replace(size_t p, size_t n,$/;"	f	class:rope
replace_copy	stl_algo.h	/^OutputIterator replace_copy(InputIterator first, InputIterator last,$/;"	f
replace_copy_if	stl_algo.h	/^OutputIterator replace_copy_if(Iterator first, Iterator last,$/;"	f
replace_if	stl_algo.h	/^void replace_if(ForwardIterator first, ForwardIterator last, Predicate pred,$/;"	f
replace_with_c_str	ropeimpl.h	/^const charT * rope<charT,Alloc>::replace_with_c_str() {$/;"	f	class:rope
requested_size	stl_tempbuf.h	/^  ptrdiff_t requested_size() const { return original_len; }$/;"	f	class:temporary_buffer
reserve	stl_bvector.h	/^  void reserve(size_type n) {$/;"	f	class:vector
reserve	stl_rope.h	/^	    void reserve(size_type res_arg = 0) {}$/;"	f	class:rope
reserve	stl_vector.h	/^  void reserve(size_type n) {$/;"	f	class:vector
reserve_elements_at_back	stl_deque.h	/^  iterator reserve_elements_at_back(size_type n) {$/;"	f	class:__deque_iterator::deque
reserve_elements_at_front	stl_deque.h	/^  iterator reserve_elements_at_front(size_type n) {$/;"	f	class:__deque_iterator::deque
reserve_map_at_back	stl_deque.h	/^  void reserve_map_at_back (size_type nodes_to_add = 1) {$/;"	f	class:__deque_iterator::deque
reserve_map_at_front	stl_deque.h	/^  void reserve_map_at_front (size_type nodes_to_add = 1) {$/;"	f	class:__deque_iterator::deque
resize	stl_bvector.h	/^  void resize(size_type new_size, bool x = bool()) {$/;"	f	class:vector
resize	stl_deque.h	/^  void resize(size_type new_size) { resize(new_size, value_type()); }$/;"	f	class:__deque_iterator::deque
resize	stl_deque.h	/^  void resize(size_type new_size, const value_type& x) {$/;"	f	class:__deque_iterator::deque
resize	stl_hash_map.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_map
resize	stl_hash_map.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_multimap
resize	stl_hash_set.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_multiset
resize	stl_hash_set.h	/^  void resize(size_type hint) { rep.resize(hint); }$/;"	f	class:hash_set
resize	stl_hashtable.h	/^void hashtable<V, K, HF, Ex, Eq, A>::resize(size_type num_elements_hint)$/;"	f	class:hashtable
resize	stl_list.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:list
resize	stl_list.h	/^void list<T, Alloc>::resize(size_type new_size, const T& x)$/;"	f	class:list
resize	stl_rope.h	/^	    void resize(size_type n) {}$/;"	f	class:rope
resize	stl_rope.h	/^	    void resize(size_type n, charT c) {}$/;"	f	class:rope
resize	stl_slist.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:slist
resize	stl_slist.h	/^void slist<T, Alloc>::resize(size_type len, const T& x)$/;"	f	class:slist
resize	stl_vector.h	/^  void resize(size_type new_size) { resize(new_size, T()); }$/;"	f	class:vector
resize	stl_vector.h	/^  void resize(size_type new_size, const T& x) {$/;"	f	class:vector
result_type	stl_function.h	/^    typedef Result result_type;$/;"	t	struct:binary_function
result_type	stl_function.h	/^    typedef Result result_type;$/;"	t	struct:unary_function
result_type	stl_function.h	/^  typedef Result result_type;$/;"	t	struct:constant_void_fun
return_temporary_buffer	stl_tempbuf.h	/^void return_temporary_buffer(T* p) {$/;"	f
reverse	stl_algo.h	/^inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {$/;"	f
reverse	stl_list.h	/^void list<T, Alloc>::reverse() {$/;"	f	class:list
reverse	stl_slist.h	/^  void reverse() { if (head.next) head.next = __slist_reverse(head.next); }$/;"	f	class:slist
reverse_bidirectional_iterator	stl_iterator.h	/^  explicit reverse_bidirectional_iterator(BidirectionalIterator x)$/;"	f	class:reverse_bidirectional_iterator
reverse_bidirectional_iterator	stl_iterator.h	/^  reverse_bidirectional_iterator() {}$/;"	f	class:reverse_bidirectional_iterator
reverse_bidirectional_iterator	stl_iterator.h	/^class reverse_bidirectional_iterator {$/;"	c
reverse_copy	stl_algo.h	/^OutputIterator reverse_copy(BidirectionalIterator first,$/;"	f
reverse_iterator	stl_bvector.h	/^          reverse_iterator;$/;"	t	class:vector
reverse_iterator	stl_bvector.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:vector
reverse_iterator	stl_deque.h	/^          reverse_iterator; $/;"	t	class:__deque_iterator::deque
reverse_iterator	stl_deque.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:__deque_iterator::deque
reverse_iterator	stl_iterator.h	/^  explicit reverse_iterator(RandomAccessIterator x) : current(x) {}$/;"	f	class:reverse_iterator
reverse_iterator	stl_iterator.h	/^  explicit reverse_iterator(iterator_type x) : current(x) {}$/;"	f	class:reverse_iterator
reverse_iterator	stl_iterator.h	/^  reverse_iterator() {}$/;"	f	class:reverse_iterator
reverse_iterator	stl_iterator.h	/^  reverse_iterator(const reverse_iterator<Iter>& x) : current(x.current) {}$/;"	f	class:reverse_iterator
reverse_iterator	stl_iterator.h	/^  reverse_iterator(const self& x) : current(x.current) {}$/;"	f	class:reverse_iterator
reverse_iterator	stl_iterator.h	/^class reverse_iterator $/;"	c
reverse_iterator	stl_iterator.h	/^class reverse_iterator {$/;"	c
reverse_iterator	stl_list.h	/^  reverse_iterator; $/;"	t	class:list
reverse_iterator	stl_list.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:list
reverse_iterator	stl_map.h	/^  typedef typename rep_type::reverse_iterator reverse_iterator;$/;"	t	class:map
reverse_iterator	stl_multimap.h	/^  typedef typename rep_type::reverse_iterator reverse_iterator;$/;"	t	class:multimap
reverse_iterator	stl_multiset.h	/^  typedef typename rep_type::const_reverse_iterator reverse_iterator;$/;"	t	class:multiset
reverse_iterator	stl_rope.h	/^				 difference_type>  reverse_iterator;$/;"	t	class:rope
reverse_iterator	stl_rope.h	/^        typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:rope
reverse_iterator	stl_set.h	/^  typedef typename rep_type::const_reverse_iterator reverse_iterator;$/;"	t	class:set
reverse_iterator	stl_tree.h	/^          reverse_iterator; $/;"	t	class:rb_tree
reverse_iterator	stl_tree.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:rb_tree
reverse_iterator	stl_vector.h	/^          reverse_iterator;$/;"	t	class:vector
reverse_iterator	stl_vector.h	/^  typedef reverse_iterator<iterator> reverse_iterator;$/;"	t	class:vector
right	stl_rope.h	/^    __rope_RopeBase<charT,Alloc>* right;$/;"	m	struct:__rope_RopeConcatenation
right	stl_tree.h	/^  base_ptr right;$/;"	m	struct:__rb_tree_node_base
right	stl_tree.h	/^  static link_type& right(base_ptr x) { return (link_type&)(x->right); }$/;"	f	class:rb_tree
right	stl_tree.h	/^  static link_type& right(link_type x) { return (link_type&)(x->right); }$/;"	f	class:rb_tree
rightmost	stl_tree.h	/^  link_type& rightmost() const { return (link_type&) header->right; }$/;"	f	class:rb_tree
root	stl_rope.h	/^    RopeBase * root;     \/\/ The whole rope.$/;"	m	class:__rope_iterator_base
root	stl_rope.h	/^    my_rope * root;     \/\/ The whole rope.$/;"	m	class:__rope_charT_ref_proxy
root	stl_rope.h	/^    rope<charT,Alloc> * root;     \/\/ The whole rope.$/;"	m	class:__rope_charT_ptr_proxy
root	stl_tree.h	/^  link_type& root() const { return (link_type&) header->parent; }$/;"	f	class:rb_tree
root_rope	stl_rope.h	/^    rope<charT,Alloc> * root_rope;$/;"	m	class:__rope_iterator
rope	ropeimpl.h	/^rope<charT, Alloc>::rope(size_t n, charT c)$/;"	f	class:rope
rope	stl_rope.h	/^	rope()$/;"	f	class:rope
rope	stl_rope.h	/^	rope(RopeBase *t) : tree_ptr(t) { }$/;"	f	class:rope
rope	stl_rope.h	/^	rope(charT c)$/;"	f	class:rope
rope	stl_rope.h	/^	rope(char_producer<charT> *fn, size_t len, bool delete_fn)$/;"	f	class:rope
rope	stl_rope.h	/^	rope(const charT *i, const charT *j)$/;"	f	class:rope
rope	stl_rope.h	/^	rope(const charT *s)$/;"	f	class:rope
rope	stl_rope.h	/^	rope(const charT *s, charT *e)$/;"	f	class:rope
rope	stl_rope.h	/^	rope(const charT *s, size_t len)$/;"	f	class:rope
rope	stl_rope.h	/^	rope(const const_iterator& s, const const_iterator& e)$/;"	f	class:rope
rope	stl_rope.h	/^	rope(const iterator& s, const iterator& e)$/;"	f	class:rope
rope	stl_rope.h	/^	rope(const rope &x)$/;"	f	class:rope
rope	stl_rope.h	/^class rope {$/;"	c
rotate	ropeimpl.h	/^inline void rotate(__rope_iterator<char,__ALLOC> first,$/;"	f
rotate	stl_algo.h	/^inline void rotate(ForwardIterator first, ForwardIterator middle,$/;"	f
rotate_copy	stl_algo.h	/^OutputIterator rotate_copy(ForwardIterator first, ForwardIterator middle,$/;"	f
rounded_up_size	stl_rope.h	/^	static size_t rounded_up_size(size_t n) {$/;"	f	class:rope
rounded_up_size	stl_rope.h	/^    static size_t rounded_up_size(size_t n) {$/;"	f	struct:__rope_RopeBase
search	stl_algo.h	/^inline ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
search_n	stl_algo.h	/^ForwardIterator search_n(ForwardIterator first, ForwardIterator last,$/;"	f
second	stl_pair.h	/^  T2 second;$/;"	m	struct:pair
second_argument_type	stl_function.h	/^    typedef Arg2 second_argument_type;$/;"	t	struct:binary_function
second_type	stl_pair.h	/^  typedef T2 second_type;$/;"	t	struct:pair
select1st	stl_function.h	/^struct select1st : public unary_function<Pair, typename Pair::first_type> {$/;"	s
select2nd	stl_function.h	/^struct select2nd : public unary_function<Pair, typename Pair::second_type> {$/;"	s
self	stl_deque.h	/^  typedef __deque_iterator self;$/;"	t	struct:__deque_iterator::__deque_iterator
self	stl_iterator.h	/^                                         Distance> self;$/;"	t	class:reverse_bidirectional_iterator
self	stl_iterator.h	/^        self;$/;"	t	class:reverse_iterator
self	stl_iterator.h	/^  typedef reverse_iterator<Iterator> self;$/;"	t	class:reverse_iterator
self	stl_list.h	/^  typedef __list_iterator<T, Ref, Ptr>           self;$/;"	t	struct:__list_iterator
self	stl_slist.h	/^  typedef __slist_iterator<T, Ref, Ptr>           self;$/;"	t	struct:__slist_iterator
self	stl_tree.h	/^  typedef __rb_tree_iterator<Value, Ref, Ptr>                   self;$/;"	t	struct:__rb_tree_iterator
self_destruct_ptr	stl_rope.h	/^	    typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;$/;"	t	class:rope
self_destruct_ptr	stl_rope.h	/^	    typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;$/;"	t	class:rope
self_destruct_ptr	stl_rope.h	/^	typedef __rope_RopeBase<charT,Alloc> * self_destruct_ptr;$/;"	t	class:__rope_charT_ref_proxy
self_destruct_ptr	stl_rope.h	/^    	typedef __rope_self_destruct_ptr<charT,Alloc> self_destruct_ptr;$/;"	t	class:__rope_charT_ref_proxy
sequence_buffer	stl_rope.h	/^	sequence_buffer() : prefix(0), buf_count(0) {}$/;"	f	class:sequence_buffer
sequence_buffer	stl_rope.h	/^	sequence_buffer(const sequence_buffer & x) {$/;"	f	class:sequence_buffer
sequence_buffer	stl_rope.h	/^	sequence_buffer(sequence& s) : prefix(&s), buf_count(0) {}$/;"	f	class:sequence_buffer
sequence_buffer	stl_rope.h	/^	sequence_buffer(sequence_buffer & x) {$/;"	f	class:sequence_buffer
sequence_buffer	stl_rope.h	/^class sequence_buffer : public output_iterator {$/;"	c
set	stl_set.h	/^  explicit set(const Compare& comp) : t(comp) {}$/;"	f	class:set
set	stl_set.h	/^  set() : t(Compare()) {}$/;"	f	class:set
set	stl_set.h	/^  set(InputIterator first, InputIterator last)$/;"	f	class:set
set	stl_set.h	/^  set(InputIterator first, InputIterator last, const Compare& comp)$/;"	f	class:set
set	stl_set.h	/^  set(const set<Key, Compare, Alloc>& x) : t(x.t) {}$/;"	f	class:set
set	stl_set.h	/^  set(const value_type* first, const value_type* last) $/;"	f	class:set
set	stl_set.h	/^  set(const value_type* first, const value_type* last, const Compare& comp)$/;"	f	class:set
set	stl_set.h	/^  set(const_iterator first, const_iterator last)$/;"	f	class:set
set	stl_set.h	/^  set(const_iterator first, const_iterator last, const Compare& comp)$/;"	f	class:set
set	stl_set.h	/^class set {$/;"	c
set_difference	stl_algo.h	/^OutputIterator set_difference(InputIterator1 first1, InputIterator1 last1,$/;"	f
set_intersection	stl_algo.h	/^OutputIterator set_intersection(InputIterator1 first1, InputIterator1 last1,$/;"	f
set_malloc_handler	stl_alloc.h	/^static void (* set_malloc_handler(void (*f)()))()$/;"	f	class:__malloc_alloc_template
set_node	stl_deque.h	/^  void set_node(map_pointer new_node) {$/;"	f	struct:__deque_iterator::__deque_iterator
set_symmetric_difference	stl_algo.h	/^OutputIterator set_symmetric_difference(InputIterator1 first1,$/;"	f
set_union	stl_algo.h	/^OutputIterator set_union(InputIterator1 first1, InputIterator1 last1,$/;"	f
setbuf	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setbuf$/;"	f	class:__rope_iterator_base
setcache	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setcache$/;"	f	class:__rope_iterator_base
setcache_for_incr	ropeimpl.h	/^void __rope_iterator_base<charT,Alloc>::setcache_for_incr$/;"	f	class:__rope_iterator_base
simple_alloc	stl_alloc.h	/^class simple_alloc {$/;"	c
single_client_alloc	stl_alloc.h	/^typedef __default_alloc_template<false, 0> single_client_alloc;$/;"	t
single_client_alloc	stl_alloc.h	/^typedef malloc_alloc single_client_alloc;$/;"	t
size	stl_bvector.h	/^  size_type size() const { return size_type(end() - begin()); }$/;"	f	class:vector
size	stl_deque.h	/^  size_type size() const { return finish - start;; }$/;"	f	class:__deque_iterator::deque
size	stl_hash_map.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_map
size	stl_hash_map.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_multimap
size	stl_hash_set.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_multiset
size	stl_hash_set.h	/^  size_type size() const { return rep.size(); }$/;"	f	class:hash_set
size	stl_hashtable.h	/^  size_type size() const { return num_elements; }$/;"	f	class:hashtable
size	stl_list.h	/^  size_type size() const {$/;"	f	class:list
size	stl_map.h	/^  size_type size() const { return t.size(); }$/;"	f	class:map
size	stl_multimap.h	/^  size_type size() const { return t.size(); }$/;"	f	class:multimap
size	stl_multiset.h	/^  size_type size() const { return t.size(); }$/;"	f	class:multiset
size	stl_queue.h	/^  size_type size() const { return c.size(); }$/;"	f	class:priority_queue
size	stl_queue.h	/^  size_type size() const { return c.size(); }$/;"	f	class:queue
size	stl_rope.h	/^	size_type size() const { $/;"	f	class:rope
size	stl_rope.h	/^    size_t size;$/;"	m	struct:__rope_RopeBase
size	stl_set.h	/^  size_type size() const { return t.size(); }$/;"	f	class:set
size	stl_slist.h	/^  size_type size() const { return __slist_size(head.next); }$/;"	f	class:slist
size	stl_stack.h	/^  size_type size() const { return c.size(); }$/;"	f	class:stack
size	stl_tempbuf.h	/^  ptrdiff_t size() const { return len; }$/;"	f	class:temporary_buffer
size	stl_tree.h	/^  size_type size() const { return node_count; }$/;"	f	class:rb_tree
size	stl_vector.h	/^  size_type size() const { return size_type(end() - begin()); }$/;"	f	class:vector
size_type	defalloc.h	/^    typedef size_t size_type;$/;"	t	class:allocator
size_type	stl_bvector.h	/^  typedef size_t size_type;$/;"	t	class:vector
size_type	stl_deque.h	/^  typedef size_t size_type;$/;"	t	class:__deque_iterator::deque
size_type	stl_deque.h	/^  typedef size_t size_type;$/;"	t	struct:__deque_iterator::__deque_iterator
size_type	stl_hash_map.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_map
size_type	stl_hash_map.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_multimap
size_type	stl_hash_set.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_multiset
size_type	stl_hash_set.h	/^  typedef typename ht::size_type size_type;$/;"	t	class:hash_set
size_type	stl_hashtable.h	/^  typedef size_t            size_type;$/;"	t	class:hashtable
size_type	stl_hashtable.h	/^  typedef size_t size_type;$/;"	t	struct:__hashtable_const_iterator
size_type	stl_hashtable.h	/^  typedef size_t size_type;$/;"	t	struct:__hashtable_iterator
size_type	stl_list.h	/^  typedef size_t size_type;$/;"	t	class:list
size_type	stl_list.h	/^  typedef size_t size_type;$/;"	t	struct:__list_iterator
size_type	stl_map.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:map
size_type	stl_multimap.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:multimap
size_type	stl_multiset.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:multiset
size_type	stl_queue.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:priority_queue
size_type	stl_queue.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:queue
size_type	stl_rope.h	/^	typedef size_t size_type;$/;"	t	class:rope
size_type	stl_set.h	/^  typedef typename rep_type::size_type size_type;$/;"	t	class:set
size_type	stl_slist.h	/^  typedef size_t size_type;$/;"	t	class:slist
size_type	stl_slist.h	/^  typedef size_t size_type;$/;"	t	struct:__slist_iterator_base
size_type	stl_stack.h	/^  typedef typename Sequence::size_type size_type;$/;"	t	class:stack
size_type	stl_tree.h	/^  typedef size_t size_type;$/;"	t	class:rb_tree
size_type	stl_vector.h	/^  typedef size_t size_type;$/;"	t	class:vector
slist	stl_slist.h	/^  explicit slist(size_type n) { fill_initialize(n, value_type()); }$/;"	f	class:slist
slist	stl_slist.h	/^  slist() { head.next = 0; }$/;"	f	class:slist
slist	stl_slist.h	/^  slist(InputIterator first, InputIterator last) {$/;"	f	class:slist
slist	stl_slist.h	/^  slist(const slist& L) { range_initialize(L.begin(), L.end()); }$/;"	f	class:slist
slist	stl_slist.h	/^  slist(const value_type* first, const value_type* last) {$/;"	f	class:slist
slist	stl_slist.h	/^  slist(const_iterator first, const_iterator last) {$/;"	f	class:slist
slist	stl_slist.h	/^  slist(int n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist
slist	stl_slist.h	/^  slist(long n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist
slist	stl_slist.h	/^  slist(size_type n, const value_type& x) { fill_initialize(n, x); }$/;"	f	class:slist
slist	stl_slist.h	/^class slist$/;"	c
sort	stl_algo.h	/^inline void sort(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
sort	stl_algo.h	/^inline void sort(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
sort	stl_list.h	/^void list<T, Alloc>::sort() {$/;"	f	class:list
sort	stl_list.h	/^void list<T, Alloc>::sort(StrictWeakOrdering comp) {$/;"	f	class:list
sort	stl_slist.h	/^void slist<T,Alloc>::sort()$/;"	f	class:slist
sort	stl_slist.h	/^void slist<T,Alloc>::sort(StrictWeakOrdering comp)$/;"	f	class:slist
sort_heap	stl_heap.h	/^void sort_heap(RandomAccessIterator first, RandomAccessIterator last) {$/;"	f
sort_heap	stl_heap.h	/^void sort_heap(RandomAccessIterator first, RandomAccessIterator last,$/;"	f
splice	stl_list.h	/^  void splice(iterator position, list& x) {$/;"	f	class:list
splice	stl_list.h	/^  void splice(iterator position, list&, iterator first, iterator last) {$/;"	f	class:list
splice	stl_list.h	/^  void splice(iterator position, list&, iterator i) {$/;"	f	class:list
splice	stl_slist.h	/^  void splice(iterator pos, slist& L) {$/;"	f	class:slist
splice	stl_slist.h	/^  void splice(iterator pos, slist& L, iterator first, iterator last)$/;"	f	class:slist
splice	stl_slist.h	/^  void splice(iterator pos, slist& L, iterator i) {$/;"	f	class:slist
splice_after	stl_slist.h	/^  void splice_after(iterator pos, $/;"	f	class:slist
splice_after	stl_slist.h	/^  void splice_after(iterator pos, iterator prev)$/;"	f	class:slist
stable_partition	stl_algo.h	/^inline ForwardIterator stable_partition(ForwardIterator first,$/;"	f
stable_sort	stl_algo.h	/^inline void stable_sort(RandomAccessIterator first,$/;"	f
stack	stl_stack.h	/^class stack {$/;"	c
start	stl_bvector.h	/^  iterator start;$/;"	m	class:vector
start	stl_deque.h	/^  iterator start;$/;"	m	class:__deque_iterator::deque
start	stl_rope.h	/^    size_t start;$/;"	m	struct:__rope_RopeSubstring
start	stl_vector.h	/^  iterator start;$/;"	m	class:vector
start_free	stl_alloc.h	/^  static char *start_free;$/;"	m	class:__default_alloc_template
start_free	stl_alloc.h	/^char *__default_alloc_template<threads, inst>::start_free = 0;$/;"	m	class:__default_alloc_template
stream	stl_iterator.h	/^  istream* stream;$/;"	m	class:istream_iterator
stream	stl_iterator.h	/^  ostream* stream;$/;"	m	class:ostream_iterator
string	stl_iterator.h	/^  const char* string;$/;"	m	class:ostream_iterator
substr	stl_rope.h	/^	rope substr(const_iterator start, const_iterator end) const {$/;"	f	class:rope
substr	stl_rope.h	/^	rope substr(iterator start) const {$/;"	f	class:rope
substr	stl_rope.h	/^	rope substr(iterator start, iterator end) const {$/;"	f	class:rope
substr	stl_rope.h	/^	rope substr(size_t start, size_t len = 1) const {$/;"	f	class:rope
substr	stl_rope.h	/^	rope<charT,Alloc> substr(const_iterator start) {$/;"	f	class:rope
substring	ropeimpl.h	/^rope<charT,Alloc>::substring(RopeBase * base, size_t start, size_t endp1)$/;"	f	class:rope
substringfn	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	e	enum:__rope_RopeBase::__anon2
subtractive_rng	stl_function.h	/^  subtractive_rng() { initialize(161803398u); }$/;"	f	class:subtractive_rng
subtractive_rng	stl_function.h	/^  subtractive_rng(unsigned int seed) { initialize(seed); }$/;"	f	class:subtractive_rng
subtractive_rng	stl_function.h	/^class subtractive_rng : public unary_function<unsigned int, unsigned int> {$/;"	c
swap	stl_algobase.h	/^inline void swap(T& a, T& b) {$/;"	f
swap	stl_bvector.h	/^  void swap(__BVECTOR& x) {$/;"	f	class:vector
swap	stl_bvector.h	/^inline void swap(__bit_reference x, __bit_reference y) {$/;"	f
swap	stl_deque.h	/^  void swap(deque& x) {$/;"	f	class:__deque_iterator::deque
swap	stl_deque.h	/^inline void swap(deque<T, Alloc, BufSiz>& x, deque<T, Alloc, BufSiz>& y) {$/;"	f	struct:__deque_iterator
swap	stl_hash_map.h	/^  void swap(hash_map& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_map
swap	stl_hash_map.h	/^  void swap(hash_multimap& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_multimap
swap	stl_hash_map.h	/^inline void swap(hash_map<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f
swap	stl_hash_map.h	/^inline void swap(hash_multimap<Key, T, HashFcn, EqualKey, Alloc>& hm1,$/;"	f
swap	stl_hash_set.h	/^  void swap(hash_multiset& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_multiset
swap	stl_hash_set.h	/^  void swap(hash_set& hs) { rep.swap(hs.rep); }$/;"	f	class:hash_set
swap	stl_hash_set.h	/^inline void swap(hash_set<Val, HashFcn, EqualKey, Alloc>& hs1,$/;"	f
swap	stl_hashtable.h	/^  void swap(hashtable& ht)$/;"	f	class:hashtable
swap	stl_hashtable.h	/^inline void swap(hashtable<Val, Key, HF, Extract, EqKey, A>& ht1,$/;"	f
swap	stl_list.h	/^  void swap(list<T, Alloc>& x) { __STD::swap(node, x.node); }$/;"	f	class:list
swap	stl_list.h	/^inline void swap(list<T, Alloc>& x, list<T, Alloc>& y) {$/;"	f
swap	stl_map.h	/^  void swap(map<Key, T, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:map
swap	stl_map.h	/^inline void swap(map<Key, T, Compare, Alloc>& x, $/;"	f
swap	stl_multimap.h	/^  void swap(multimap<Key, T, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:multimap
swap	stl_multimap.h	/^inline void swap(multimap<Key, T, Compare, Alloc>& x, $/;"	f
swap	stl_multiset.h	/^  void swap(multiset<Key, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:multiset
swap	stl_multiset.h	/^inline void swap(multiset<Key, Compare, Alloc>& x, $/;"	f
swap	stl_rope.h	/^	void swap(rope& b) {$/;"	f	class:rope
swap	stl_rope.h	/^inline void swap(crope x, crope y) { x.swap(y); }$/;"	f
swap	stl_rope.h	/^inline void swap(rope<charT, Alloc>& x, rope<charT, Alloc>& y) {$/;"	f
swap	stl_rope.h	/^inline void swap(wrope x, wrope y) { x.swap(y); }$/;"	f
swap	stl_set.h	/^  void swap(set<Key, Compare, Alloc>& x) { t.swap(x.t); }$/;"	f	class:set
swap	stl_set.h	/^inline void swap(set<Key, Compare, Alloc>& x, $/;"	f
swap	stl_slist.h	/^  void swap(slist& L)$/;"	f	class:slist
swap	stl_slist.h	/^inline void swap(slist<T, Alloc>& x, slist<T, Alloc>& y) {$/;"	f
swap	stl_tree.h	/^  void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& t) {$/;"	f	class:rb_tree
swap	stl_tree.h	/^inline void swap(rb_tree<Key, Value, KeyOfValue, Compare, Alloc>& x, $/;"	f
swap	stl_vector.h	/^  void swap(vector<T, Alloc>& x) {$/;"	f	class:vector
swap	stl_vector.h	/^inline void swap(vector<T, Alloc>& x, vector<T, Alloc>& y) {$/;"	f
swap_lock	ropeimpl.h	/^    pthread_mutex_t rope<charT,Alloc>::swap_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	m	class:rope
swap_lock	stl_rope.h	/^	    static pthread_mutex_t swap_lock;$/;"	m	class:rope
swap_ranges	stl_algo.h	/^ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1,$/;"	f
t	stl_map.h	/^  rep_type t;  \/\/ red-black tree representing map$/;"	m	class:map
t	stl_multimap.h	/^  rep_type t;  \/\/ red-black tree representing multimap$/;"	m	class:multimap
t	stl_multiset.h	/^  rep_type t;  \/\/ red-black tree representing multiset$/;"	m	class:multiset
t	stl_set.h	/^  rep_type t;  \/\/ red-black tree representing set$/;"	m	class:set
table	stl_function.h	/^  unsigned int table[55];$/;"	m	class:subtractive_rng
tag	stl_rope.h	/^    enum {leaf, concat, substringfn, function} tag:8;$/;"	m	struct:__rope_RopeBase	typeref:enum:__rope_RopeBase::__anon2
temporary_buffer	stl_tempbuf.h	/^  temporary_buffer(ForwardIterator first, ForwardIterator last) {$/;"	f	class:temporary_buffer
temporary_buffer	stl_tempbuf.h	/^  temporary_buffer(const temporary_buffer&) {}$/;"	f	class:temporary_buffer
temporary_buffer	stl_tempbuf.h	/^class temporary_buffer {$/;"	c
this_dummy_member_must_be_first	type_traits.h	/^   typedef __true_type     this_dummy_member_must_be_first;$/;"	t	struct:__type_traits
tmp_buf	stl_rope.h	/^    charT tmp_buf[iterator_buf_len];$/;"	m	class:__rope_iterator_base
top	stl_queue.h	/^  const_reference top() const { return c.front(); }$/;"	f	class:priority_queue
top	stl_stack.h	/^  const_reference top() const { return c.back(); }$/;"	f	class:stack
top	stl_stack.h	/^  reference top() { return c.back(); }$/;"	f	class:stack
transfer	stl_list.h	/^  void transfer(iterator position, iterator first, iterator last) {$/;"	f	class:list
transform	stl_algo.h	/^OutputIterator transform(InputIterator first, InputIterator last,$/;"	f
transform	stl_algo.h	/^OutputIterator transform(InputIterator1 first1, InputIterator1 last1,$/;"	f
tree_concat	ropeimpl.h	/^rope<charT,Alloc>::tree_concat (RopeBase * left, RopeBase * right)$/;"	f	class:rope
tree_ptr	stl_rope.h	/^	RopeBase *tree_ptr;$/;"	m	class:rope
true	stl_config.h	172;"	d
typename	stl_config.h	177;"	d
unary_compose	stl_function.h	/^  unary_compose(const Operation1& x, const Operation2& y) : op1(x), op2(y) {}$/;"	f	class:unary_compose
unary_compose	stl_function.h	/^class unary_compose : public unary_function<typename Operation2::argument_type,$/;"	c
unary_function	stl_function.h	/^struct unary_function {$/;"	s
unary_negate	stl_function.h	/^  explicit unary_negate(const Predicate& x) : pred(x) {}$/;"	f	class:unary_negate
unary_negate	stl_function.h	/^class unary_negate$/;"	c
uninitialized_copy	stl_uninitialized.h	/^  uninitialized_copy(InputIterator first, InputIterator last,$/;"	f
uninitialized_copy	stl_uninitialized.h	/^inline char* uninitialized_copy(const char* first, const char* last,$/;"	f
uninitialized_copy	stl_uninitialized.h	/^inline wchar_t* uninitialized_copy(const wchar_t* first, const wchar_t* last,$/;"	f
uninitialized_copy_n	stl_uninitialized.h	/^uninitialized_copy_n(InputIterator first, Size count,$/;"	f
uninitialized_fill	stl_uninitialized.h	/^inline void uninitialized_fill(ForwardIterator first, ForwardIterator last, $/;"	f
uninitialized_fill_n	stl_uninitialized.h	/^inline ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n,$/;"	f
unique	stl_algo.h	/^ForwardIterator unique(ForwardIterator first, ForwardIterator last) {$/;"	f
unique	stl_algo.h	/^ForwardIterator unique(ForwardIterator first, ForwardIterator last,$/;"	f
unique	stl_list.h	/^void list<T, Alloc>::unique() {$/;"	f	class:list
unique	stl_list.h	/^void list<T, Alloc>::unique(BinaryPredicate binary_pred) {$/;"	f	class:list
unique	stl_slist.h	/^void slist<T,Alloc>::unique()$/;"	f	class:slist
unique	stl_slist.h	/^void slist<T,Alloc>::unique(BinaryPredicate pred)$/;"	f	class:slist
unique_copy	stl_algo.h	/^inline OutputIterator unique_copy(InputIterator first, InputIterator last,$/;"	f
unref	stl_rope.h	/^	  static void unref(RopeBase* t) {}$/;"	f	class:rope
unref	stl_rope.h	/^	  static void unref(RopeBase* t)$/;"	f	class:rope
unref	stl_rope.h	/^	  static void unref(__rope_RopeBase* t) {}$/;"	f	struct:__rope_RopeBase
unref	stl_rope.h	/^	  static void unref(__rope_RopeBase* t)$/;"	f	struct:__rope_RopeBase
unref_nonnil	stl_rope.h	/^	  void unref_nonnil() {}$/;"	f	struct:__rope_RopeBase
unref_nonnil	stl_rope.h	/^	  void unref_nonnil()$/;"	f	struct:__rope_RopeBase
upper_bound	stl_algo.h	/^inline ForwardIterator upper_bound(ForwardIterator first, ForwardIterator last,$/;"	f
upper_bound	stl_map.h	/^  const_iterator upper_bound(const key_type& x) const {$/;"	f	class:map
upper_bound	stl_map.h	/^  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }$/;"	f	class:map
upper_bound	stl_multimap.h	/^  const_iterator upper_bound(const key_type& x) const {$/;"	f	class:multimap
upper_bound	stl_multimap.h	/^  iterator upper_bound(const key_type& x) {return t.upper_bound(x); }$/;"	f	class:multimap
upper_bound	stl_multiset.h	/^  iterator upper_bound(const key_type& x) const {$/;"	f	class:multiset
upper_bound	stl_set.h	/^  iterator upper_bound(const key_type& x) const {$/;"	f	class:set
upper_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) const {$/;"	f	class:rb_tree
upper_bound	stl_tree.h	/^rb_tree<Key, Value, KeyOfValue, Compare, Alloc>::upper_bound(const Key& k) {$/;"	f	class:rb_tree
val	stl_function.h	/^  Result val;$/;"	m	struct:constant_binary_fun
val	stl_function.h	/^  Result val;$/;"	m	struct:constant_unary_fun
val	stl_function.h	/^  result_type val;$/;"	m	struct:constant_void_fun
val	stl_hashtable.h	/^  Value val;$/;"	m	struct:__hashtable_node
value	stl_function.h	/^  typename Operation::first_argument_type value;$/;"	m	class:binder1st
value	stl_function.h	/^  typename Operation::second_argument_type value;$/;"	m	class:binder2nd
value	stl_iterator.h	/^  T value;$/;"	m	class:istream_iterator
value	stl_tree.h	/^  static reference value(base_ptr x) { return ((link_type)x)->value_field; }$/;"	f	class:rb_tree
value	stl_tree.h	/^  static reference value(link_type x) { return x->value_field; }$/;"	f	class:rb_tree
value_comp	stl_map.h	/^  value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:map
value_comp	stl_multimap.h	/^  value_compare value_comp() const { return value_compare(t.key_comp()); }$/;"	f	class:multimap
value_comp	stl_multiset.h	/^  value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:multiset
value_comp	stl_set.h	/^  value_compare value_comp() const { return t.key_comp(); }$/;"	f	class:set
value_compare	stl_map.h	/^    value_compare(Compare c) : comp(c) {}$/;"	f	class:map::value_compare
value_compare	stl_map.h	/^  class value_compare$/;"	c	class:map
value_compare	stl_multimap.h	/^    value_compare(Compare c) : comp(c) {}$/;"	f	class:multimap::value_compare
value_compare	stl_multimap.h	/^  class value_compare : public binary_function<value_type, value_type, bool> {$/;"	c	class:multimap
value_compare	stl_multiset.h	/^  typedef Compare value_compare;$/;"	t	class:multiset
value_compare	stl_set.h	/^  typedef Compare value_compare;$/;"	t	class:set
value_field	stl_tree.h	/^  Value value_field;$/;"	m	struct:__rb_tree_node
value_type	defalloc.h	/^    typedef T value_type;$/;"	t	class:allocator
value_type	stl_bvector.h	/^  typedef bool value_type;$/;"	t	class:vector
value_type	stl_deque.h	/^  typedef T value_type;$/;"	t	class:__deque_iterator::deque
value_type	stl_deque.h	/^  typedef T value_type;$/;"	t	struct:__deque_iterator::__deque_iterator
value_type	stl_deque.h	/^inline T* value_type(const __deque_iterator<T, Ref, Ptr, BufSiz>&) {$/;"	f	struct:__deque_iterator
value_type	stl_deque.h	/^inline T* value_type(const __deque_iterator<T, Ref, Ptr>&) { return 0; }$/;"	f	struct:__deque_iterator
value_type	stl_hash_map.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_map
value_type	stl_hash_map.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_multimap
value_type	stl_hash_set.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_multiset
value_type	stl_hash_set.h	/^  typedef typename ht::value_type value_type;$/;"	t	class:hash_set
value_type	stl_hashtable.h	/^  typedef Value value_type;$/;"	t	class:hashtable
value_type	stl_hashtable.h	/^  typedef Value value_type;$/;"	t	struct:__hashtable_const_iterator
value_type	stl_hashtable.h	/^  typedef Value value_type;$/;"	t	struct:__hashtable_iterator
value_type	stl_hashtable.h	/^inline V* value_type(const __hashtable_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
value_type	stl_hashtable.h	/^value_type(const __hashtable_const_iterator<V, K, HF, ExK, EqK, All>&)$/;"	f
value_type	stl_iterator.h	/^          value_type;$/;"	t	class:reverse_iterator
value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	class:reverse_bidirectional_iterator
value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	class:reverse_iterator
value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:bidirectional_iterator
value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:iterator_traits
value_type	stl_iterator.h	/^  typedef T                          value_type;$/;"	t	struct:random_access_iterator
value_type	stl_iterator.h	/^  typedef T                    value_type;$/;"	t	struct:forward_iterator
value_type	stl_iterator.h	/^  typedef T                  value_type;$/;"	t	class:istream_iterator
value_type	stl_iterator.h	/^  typedef T                  value_type;$/;"	t	struct:input_iterator
value_type	stl_iterator.h	/^  typedef T         value_type;$/;"	t	struct:iterator
value_type	stl_iterator.h	/^  typedef typename Iterator::value_type        value_type;$/;"	t	struct:iterator_traits
value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:back_insert_iterator
value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:front_insert_iterator
value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:insert_iterator
value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	class:ostream_iterator
value_type	stl_iterator.h	/^  typedef void                value_type;$/;"	t	struct:output_iterator
value_type	stl_iterator.h	/^inline T* value_type(const T*) { return (T*)(0); }$/;"	f
value_type	stl_iterator.h	/^inline T* value_type(const bidirectional_iterator<T, Distance>&) {$/;"	f
value_type	stl_iterator.h	/^inline T* value_type(const forward_iterator<T, Distance>&) {$/;"	f
value_type	stl_iterator.h	/^inline T* value_type(const input_iterator<T, Distance>&) {$/;"	f
value_type	stl_iterator.h	/^inline T* value_type(const istream_iterator<T, Distance>&) { return (T*) 0; }$/;"	f
value_type	stl_iterator.h	/^inline T* value_type(const random_access_iterator<T, Distance>&) {$/;"	f
value_type	stl_iterator.h	/^inline T* value_type(const reverse_iterator<RandomAccessIterator, T,$/;"	f
value_type	stl_iterator.h	/^value_type(const Iterator&) {$/;"	f
value_type	stl_iterator.h	/^value_type(const reverse_bidirectional_iterator<BidirectionalIterator, T,$/;"	f
value_type	stl_list.h	/^  typedef T value_type;$/;"	t	class:list
value_type	stl_list.h	/^  typedef T value_type;$/;"	t	struct:__list_iterator
value_type	stl_list.h	/^value_type(const __list_iterator<T, Ref, Ptr>&) {$/;"	f
value_type	stl_map.h	/^  typedef pair<const Key, T> value_type;$/;"	t	class:map
value_type	stl_multimap.h	/^  typedef pair<const Key, T> value_type;$/;"	t	class:multimap
value_type	stl_multiset.h	/^  typedef Key value_type;$/;"	t	class:multiset
value_type	stl_queue.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:priority_queue
value_type	stl_queue.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:queue
value_type	stl_raw_storage_iter.h	/^  typedef void                value_type;$/;"	t	class:raw_storage_iterator
value_type	stl_rope.h	/^	    typedef typename sequence::value_type value_type;$/;"	t	class:sequence_buffer
value_type	stl_rope.h	/^	typedef charT value_type;$/;"	t	class:rope
value_type	stl_set.h	/^  typedef Key value_type;$/;"	t	class:set
value_type	stl_slist.h	/^  typedef T value_type;$/;"	t	class:slist
value_type	stl_slist.h	/^  typedef T value_type;$/;"	t	struct:__slist_iterator
value_type	stl_slist.h	/^value_type(const __slist_iterator<T, Ref, Ptr>&) {$/;"	f
value_type	stl_stack.h	/^  typedef typename Sequence::value_type value_type;$/;"	t	class:stack
value_type	stl_tree.h	/^  typedef Value value_type;$/;"	t	class:rb_tree
value_type	stl_tree.h	/^  typedef Value value_type;$/;"	t	struct:__rb_tree_iterator
value_type	stl_tree.h	/^inline Value* value_type(const __rb_tree_iterator<Value, Ref, Ptr>&) {$/;"	f
value_type	stl_vector.h	/^  typedef T value_type;$/;"	t	class:vector
vector	stl_bvector.h	/^template<class Alloc> class vector<bool, Alloc>$/;"	c
vector	stl_vector.h	/^  explicit vector(size_type n) { fill_initialize(n, T()); }$/;"	f	class:vector
vector	stl_vector.h	/^  vector() : start(0), finish(0), end_of_storage(0) {}$/;"	f	class:vector
vector	stl_vector.h	/^  vector(InputIterator first, InputIterator last) :$/;"	f	class:vector
vector	stl_vector.h	/^  vector(const vector<T, Alloc>& x) {$/;"	f	class:vector
vector	stl_vector.h	/^  vector(const_iterator first, const_iterator last) {$/;"	f	class:vector
vector	stl_vector.h	/^  vector(int n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector
vector	stl_vector.h	/^  vector(long n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector
vector	stl_vector.h	/^  vector(size_type n, const T& value) { fill_initialize(n, value); }$/;"	f	class:vector
vector	stl_vector.h	/^class vector {$/;"	c
void_pointer	stl_list.h	/^  typedef void* void_pointer;$/;"	t	class:list
void_pointer	stl_list.h	/^  typedef void* void_pointer;$/;"	t	struct:__list_node
void_pointer	stl_tree.h	/^  typedef void* void_pointer;$/;"	t	class:rb_tree
write	stl_rope.h	/^	sequence_buffer& write(value_type *s, size_t len)$/;"	f	class:sequence_buffer
wrope	stl_rope.h	/^typedef rope<wchar_t, __ALLOC> wrope;$/;"	t
~__BVECTOR	stl_bvector.h	/^  ~__BVECTOR() { deallocate(); }$/;"	f	class:vector
~__rope_RopeSubstring	stl_rope.h	/^    virtual ~__rope_RopeSubstring() {}$/;"	f	struct:__rope_RopeSubstring
~__rope_char_consumer	stl_rope.h	/^	virtual ~__rope_char_consumer() {};$/;"	f	class:__rope_char_consumer
~__rope_find_char_char_consumer	ropeimpl.h	/^	~__rope_find_char_char_consumer() {}$/;"	f	class:__rope_find_char_char_consumer
~__rope_flatten_char_consumer	ropeimpl.h	/^	~__rope_flatten_char_consumer() {}$/;"	f	class:__rope_flatten_char_consumer
~__rope_insert_char_consumer	ropeimpl.h	/^	~__rope_insert_char_consumer() { };$/;"	f	class:__rope_insert_char_consumer
~__rope_iterator	stl_rope.h	/^    ~__rope_iterator() {$/;"	f	class:__rope_iterator
~__rope_self_destruct_ptr	stl_rope.h	/^    ~__rope_self_destruct_ptr() { __rope_RopeBase<charT,Alloc>::unref(ptr); }$/;"	f	struct:__rope_self_destruct_ptr
~char_producer	stl_rope.h	/^	virtual ~char_producer() {};$/;"	f	class:char_producer
~deque	stl_deque.h	/^  ~deque() {$/;"	f	class:__deque_iterator::deque
~hashtable	stl_hashtable.h	/^  ~hashtable() { clear(); }$/;"	f	class:hashtable
~list	stl_list.h	/^  ~list() {$/;"	f	class:list
~lock	stl_alloc.h	/^            ~lock() { __NODE_ALLOCATOR_UNLOCK; }$/;"	f	class:__default_alloc_template::lock
~rb_tree	stl_tree.h	/^  ~rb_tree() {$/;"	f	class:rb_tree
~rope	stl_rope.h	/^	~rope()$/;"	f	class:rope
~sequence_buffer	stl_rope.h	/^	~sequence_buffer() { flush(); }$/;"	f	class:sequence_buffer
~slist	stl_slist.h	/^  ~slist() { clear(); }$/;"	f	class:slist
~temporary_buffer	stl_tempbuf.h	/^  ~temporary_buffer() {  $/;"	f	class:temporary_buffer
~vector	stl_vector.h	/^  ~vector() { $/;"	f	class:vector
